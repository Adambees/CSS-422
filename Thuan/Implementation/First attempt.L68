00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 3/12/2018 5:05:47 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : 68k Disassembler
00000000                             3  * Written by : Thuan Tran
00000000                             4  * Date       : March 11th, 2018
00000000                             5  * Description: Load a test file, enter starting and ending address. Press enter to see it disassemble every line
00000000                             6  *-----------------------------------------------------------
00000000                             7  
00000000                             8  *** A2 will be used as the address in which it will iterate through all the way until ending adrress
00000000                             9  *** A3 will be used to store the ending address
00000000                            10  
00000000  =00000100                 11  STARTING_ADDRESS            EQU    $100 * User input starting address
00000000  =00000150                 12  ENDING_ADDRESS              EQU    $150 * User input ending address
00000000  =00000200                 13  TEMP_CURRENT_4_NIBBLES      EQU    $200 * Temporary variable to hold 4 nibble at a time
00000000  =00000250                 14  DESTINATION_VAR             EQU    $250 * Used to hold the Address number     (11-9th bit)
00000000  =00000300                 15  DESTINATION_MODE            EQU    $300 * Used to hold the mode of destination (8-6 bit)
00000000  =00000350                 16  SOURCE_MODE                 EQU    $350 * used to hold the mode of the source (5-3)
00000000  =00000400                 17  SOURCE_VAR                  EQU    $400 * Used to hold the address number of source (2-0 bit)
00000000  =00000550                 18  THIRD_TEMP_VAR              EQU    $550 * Used as an arbitrary storage for data
00000000  =00000600                 19  FOURTH_TEMP_VAR             EQU    $600 * Used to prevent overwrite to (A1) when getting end address
00000000  =00000650                 20  FIFTH_TEMP_VAR              EQU    $650 * Used to prevent overwrite to (A1) when getting start address
00000000  =00000750                 21  TEMP_CURRENT_2_NIBBLES      EQU    $750 * Temporary variable to store 2 nibble at a time
00000000                            22  
00000000                            23  ***
00000000                            24  * Beginning of the program
00000000                            25  ***
00000000                            26  
00001000                            27      ORG    $1000
00001000                            28  START:                  ; first instruction of program
00001000                            29  
00001000                            30  ********************************************************************************
00001000                            31  *****************************************
00001000                            32  * Start of input and parsing op code section
00001000                            33  *****************************************
00001000                            34  ********************************************************************************
00001000                            35  
00001000                            36  ***
00001000                            37  * Display welcome prompt to user and ask for starting address
00001000                            38  ***
00001000                            39  GET_START_ADDRESS
00001000  43F9 00002162             40      LEA         INTRO_STARTING,A1                       * Welcome the user
00001006  103C 000D                 41      MOVE.B      #13,D0                                  * Nice to have carry and line feed
0000100A  4E4F                      42      TRAP        #15
0000100C  227C 00000000             43      MOVEA.L     #0,A1                                   * Clear what is in A1
00001012  43F8 0650                 44      LEA         FIFTH_TEMP_VAR,A1                       * This was made so that when we read a string, it won't overide (A1)
00001016  4240                      45      CLR         D0
00001018  4241                      46      CLR         D1
0000101A  103C 0002                 47      MOVE.B      #2,D0                                   * Get a string input that represent the user
0000101E  4E4F                      48      TRAP        #15
00001020  6000 003E                 49      BRA         CONVERT_ASCII_TO_HEX
00001024                            50  
00001024                            51  ***
00001024                            52  * Display prompt to user and ask for ending address
00001024                            53  ***
00001024                            54  GET_END_ADDRESS
00001024  43F9 00002182             55      LEA         INTRO_ENDING,A1                         * Now time to get the ending address
0000102A  103C 000D                 56      MOVE.B      #13,D0
0000102E  4E4F                      57      TRAP        #15
00001030  43F8 0600                 58      LEA         FOURTH_TEMP_VAR,A1                      *Same like get starting address
00001034  103C 0002                 59      MOVE.B      #2,D0
00001038  4E4F                      60      TRAP        #15
0000103A  6000 0024                 61      BRA         CONVERT_ASCII_TO_HEX
0000103E                            62  
0000103E                            63  ***
0000103E                            64  * Parsing 4 nibbles sequentially and decoding them based on the first nibble (left most)
0000103E                            65  ***
0000103E                            66  PARSING_OP_CODE
0000103E  4EB9 00001926             67      JSR         PRINT_ADDRESS_LOCATION
00001044  4EB9 000019DE             68      JSR         GET_NEXT_FOUR_NIBBLE
0000104A  3638 0200                 69      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
0000104E  4EB9 000019BE             70      JSR         GET_THE_FIRST_NIBBLE
00001054  C6FC 0006                 71      MULU        #6,D3                                   * Get the index
00001058  4EB0 3000                 72      JSR         0(A0,D3)                                * Jump to the table depemding on first nibble
0000105C  FFFF FFFF                 73      SIMHALT
00001060                            74  
00001060                            75  ***
00001060                            76  *This is called during the first part of program, when trying to convert user starting and ending address
00001060                            77  * Convert 0-9 and A-F in ASCII to Hex Value
00001060                            78  *ascii table http://www.asciitable.com/
00001060                            79  ***
00001060                            80  CONVERT_ASCII_TO_HEX
00001060  1019                      81      MOVE.B      (A1)+,D0                                * Go through each byte of the address
00001062  B03C 0030                 82      CMP.B       #$30,D0                                 * Valid data are from $30 - $39 ( 0-9) and $41 - $46 (A-F)
00001066  6D00 00B8                 83      BLT         ERROR_INVALID_INPUT
0000106A  B03C 0039                 84      CMP.B       #$39,D0                                 * check if in the range number of hex character
0000106E  6E00 0016                 85      BGT         CONVERT_CHARACTER_ASCII_TO_HEX
00001072  0400 0030                 86      SUB.B       #$30,D0                                 * Get the hex range from '0-9'
00001076  D680                      87      ADD.L       D0,D3
00001078  5341                      88      SUBI        #1,D1                                   * Decrement the counter for length of address
0000107A  B23C 0000                 89      CMP.B       #0,D1
0000107E  6700 002A                 90      BEQ         FINISH_CONVERT_STARTING_ADDRESS
00001082  E98B                      91      LSL.L       #4,D3                                   * Get space for next nibble
00001084  60DA                      92      BRA         CONVERT_ASCII_TO_HEX
00001086                            93  
00001086                            94  ***
00001086                            95  * Convert A-F in ASCII to hex value
00001086                            96  ***
00001086                            97  CONVERT_CHARACTER_ASCII_TO_HEX
00001086  B03C 0041                 98      CMP.B       #$41,D0                                 * At this point, the data must be larger than number
0000108A  6D00 0094                 99      BLT         ERROR_INVALID_INPUT                     * Only $41 - 46 are valid
0000108E  B03C 0046                100      CMP.B       #$46,D0
00001092  6E00 008C                101      BGT         ERROR_INVALID_INPUT                     * Greater than $46, nope
00001096  0400 0037                102      SUB.B       #$37,D0                                 * Get the A-F value
0000109A  D680                     103      ADD.L       D0,D3                                   * Save the value
0000109C  5341                     104      SUBI        #1,D1                                   * Decrement the counter
0000109E  B23C 0000                105      CMP.B       #0,D1
000010A2  6700 0006                106      BEQ         FINISH_CONVERT_STARTING_ADDRESS
000010A6  E98B                     107      LSL.L       #4,D3                                   * Shift the value to the left 4 bits to save room for another nibble
000010A8  60B6                     108      BRA         CONVERT_ASCII_TO_HEX
000010AA                           109  
000010AA                           110  ***
000010AA                           111  *   Save the starting addres to an appropriate place and also test if it is valid
000010AA                           112  ***
000010AA                           113  FINISH_CONVERT_STARTING_ADDRESS
000010AA  0803 0000                114      BTST        #0,D3                                   * Test last bit of the address to see if it is even or odd
000010AE  6600 0040                115      BNE         INVALID_STARTING_ADDRESS
000010B2  B47C 0001                116      CMP         #1,D2                                   * Check if we are doing starting or ending address
000010B6  6700 000C                117      BEQ         FINISH_CONVERT_ENDING_ADDRESS
000010BA  5242                     118      ADDI        #1,D2                                   * Counter to make sure that we are doing the ending address
000010BC  21C3 0100                119      MOVE.L      D3,STARTING_ADDRESS
000010C0  6000 FF62                120      BRA         GET_END_ADDRESS
000010C4                           121  
000010C4                           122  ***
000010C4                           123  * Save the ending address to an appropriate place and also test if it is valid
000010C4                           124  ***
000010C4                           125  FINISH_CONVERT_ENDING_ADDRESS
000010C4  0803 0000                126      BTST        #0,D3                                   * Check for odd address
000010C8  6600 003E                127      BNE         INVALID_ENDING_ADDRESS
000010CC  B6B8 0100                128      CMP.L       STARTING_ADDRESS, D3                    * Check if the ending address is less than or equal starting address
000010D0  6F00 0036                129      BLE         INVALID_ENDING_ADDRESS
000010D4  4242                     130      CLR.W       D2                                      * Clear the second data register for future use
000010D6  21C3 0150                131      MOVE.L      D3,ENDING_ADDRESS
000010DA  4243                     132      CLR.W       D3
000010DC  43F9 000022EA            133      LEA         SPACE,A1
000010E2  103C 000D                134      MOVE.B      #13,D0
000010E6  4E4F                     135      TRAP        #15
000010E8  6000 0090                136      BRA         PREPARE_START_AND_END_ADDRESS
000010EC  FFFF FFFF                137      SIMHALT
000010F0                           138  
000010F0                           139  ***
000010F0                           140  * Display the prompt invalid and ask user to enter again for invalid starting address
000010F0                           141  ***
000010F0                           142  INVALID_STARTING_ADDRESS
000010F0  227C 00000000            143      MOVEA.L     #0,A1
000010F6  43F9 000021A0            144      LEA         INVALID_INPUT,A1
000010FC  103C 000D                145      MOVE.B      #13,D0
00001100  4E4F                     146      TRAP        #15
00001102  4243                     147      CLR         D3
00001104  6000 FEFA                148      BRA         GET_START_ADDRESS
00001108                           149  
00001108                           150  ***
00001108                           151  * Display the prompt invalid and ask user to enter again for ending address
00001108                           152  ***
00001108                           153  INVALID_ENDING_ADDRESS
00001108  227C 00000000            154      MOVEA.L     #0,A1
0000110E  43F9 000021A0            155      LEA         INVALID_INPUT,A1
00001114  103C 000D                156      MOVE.B      #13,D0
00001118  4E4F                     157      TRAP        #15
0000111A  4243                     158      CLR         D3
0000111C  6000 FF06                159      BRA         GET_END_ADDRESS
00001120                           160  
00001120                           161  ***
00001120                           162  * Used to direct invalid address entered either to invalid starting or ending address
00001120                           163  ***
00001120                           164  ERROR_INVALID_INPUT
00001120  B47C 0001                165      CMP         #1,D2
00001124  67E2                     166      BEQ         INVALID_ENDING_ADDRESS
00001126  60C8                     167      BRA         INVALID_STARTING_ADDRESS
00001128                           168  
00001128                           169  ***
00001128                           170  * This is usally called during the program's execution.
00001128                           171  * Used for printing out address location, immediate data, absolute short and long ,..etc
00001128                           172  * Print out each nibble at a time (4 nibbles total)
00001128                           173  ***
00001128                           174  CONVERT_HEX_TO_ASCII
00001128  49F9 00001E3E            175      LEA         HEX_CHARACTER_JUMP_TABLE,A4             * Load the table to print out ascii charracter
0000112E  3638 0200                176      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001132  4EB9 000019BE            177      JSR         GET_THE_FIRST_NIBBLE                    * Get the left most hex value and convert
00001138  C6FC 0006                178      MULU        #6,D3
0000113C  4EB4 3000                179      JSR         0(A4,D3)
00001140  3638 0200                180      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001144  4EB9 000019C4            181      JSR         GET_THE_SECOND_NIBBLE
0000114A  C6FC 0006                182      MULU        #6,D3
0000114E  4EB4 3000                183      JSR         0(A4,D3)
00001152  3638 0200                184      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001156  4EB9 000019CC            185      JSR         GET_THE_THIRD_NIBBLE
0000115C  C6FC 0006                186      MULU        #6,D3
00001160  4EB4 3000                187      JSR         0(A4,D3)
00001164  3638 0200                188      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001168  4EB9 000019D4            189      JSR         GET_THE_FOURTH_NIBBLE
0000116E  C6FC 0006                190      MULU        #6,D3
00001172  4EB4 3000                191      JSR         0(A4,D3)
00001176  4243                     192      CLR.W       D3
00001178  4E75                     193      RTS
0000117A                           194  
0000117A                           195  
0000117A                           196  ***
0000117A                           197  * Called when starting and ending address was entered and converted correctly
0000117A                           198  ***
0000117A                           199  PREPARE_START_AND_END_ADDRESS
0000117A  41F9 00001A94            200      LEA         FIRST_NIBBLE_JUMP_TABLE,A0              * Prepare the jump table for first nibble decoding
00001180  2478 0100                201      MOVE.L      STARTING_ADDRESS,A2
00001184  2678 0150                202      MOVE.L      ENDING_ADDRESS,A3
00001188  6000 FEB4                203      BRA         PARSING_OP_CODE                         * Start parsing the opcode now
0000118C                           204  
0000118C                           205  ***
0000118C                           206  * Wait for the user to press enter to continue
0000118C                           207  ***
0000118C                           208  USER_INPUT_ENTER
0000118C  103C 0005                209      MOVE.B      #5,D0
00001190  4E4F                     210      TRAP        #15
00001192  4E75                     211      RTS
00001194                           212  
00001194                           213  
00001194                           214  ********************************************************************************
00001194                           215  *********************************************
00001194                           216  * Print the decoded opcode and data to console
00001194                           217  * This section will also be the place where most of the logic is done
00001194                           218  *********************************************
00001194                           219  ********************************************************************************
00001194                           220  
00001194                           221  
00001194                           222  ***
00001194                           223  * Called when an invalid instructions or data accessing mode was encounterd
00001194                           224  ***
00001194                           225  INVALID
00001194  43F9 000022AE            226      LEA         DATA_VALUE,A1
0000119A  4EB9 000018EA            227      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
000011A0  4EB9 000019A6            228      JSR         PRINT_EMPTY_SPACE
000011A6  4EB9 0000199A            229      JSR         PRINT_HEX_SYMBOL
000011AC  4EB8 1128                230      JSR         CONVERT_HEX_TO_ASCII                    * Print out the op code that was not decoded
000011B0  43F9 000022EA            231      LEA         SPACE,A1 * Go to new line
000011B6  103C 000E                232      MOVE.B      #14,D0
000011BA  4E4F                     233      TRAP        #15
000011BC  61CE                     234      BSR         USER_INPUT_ENTER
000011BE  6000 FE7E                235      BRA         PARSING_OP_CODE                         * Get the next four nibbles and parsing
000011C2                           236  
000011C2                           237  ***
000011C2                           238  * Print out the NEG Instruction with only 1 operands to follow
000011C2                           239  ***
000011C2                           240  PRINT_OUT_NEG
000011C2  3638 0200                241      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
000011C6  4EB9 000019F4            242      JSR         GET_NORMAL_SIZE
000011CC  B67C 0003                243      CMP         #%11,D3
000011D0  67C2                     244      BEQ         INVALID                                 * NEG can only have normal size ,01,00,10
000011D2  43F9 00002226            245      LEA         NEG_VALUE,A1                            * Print NEG to screen
000011D8  4EB9 000018EA            246      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
000011DE  4EB9 000012D4            247      JSR         PRINT_NORMAL_SUFFIX
000011E4  3638 0200                248      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
000011E8  4EB9 00001A16            249      JSR         CHECK_TYPE_DATA                         * Extract the mode and register
000011EE  4EB9 000018F2            250      JSR         PRINT_DATA_MODE_SOURCE
000011F4  6196                     251      BSR         USER_INPUT_ENTER
000011F6  6000 FE46                252      BRA         PARSING_OP_CODE
000011FA  4E75                     253      RTS
000011FC                           254  
000011FC                           255  ***
000011FC                           256  * Print out the NOP instructions with no operands to follow
000011FC                           257  ***
000011FC                           258  PRINT_OUT_NOP
000011FC  43F9 00002208            259      LEA         NOP_VALUE,A1 * Display the NOP message
00001202  4EB9 000018EA            260      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001208  6182                     261      BSR         USER_INPUT_ENTER
0000120A  6000 FE32                262      BRA         PARSING_OP_CODE
0000120E  4E75                     263      RTS
00001210                           264  
00001210                           265  ***
00001210                           266  * Print out the RTS instruction with no operands to follow
00001210                           267  ***
00001210                           268  PRINT_OUT_RTS
00001210  43F9 0000220E            269      LEA         RTS_VALUE,A1
00001216  4EB9 000018EA            270      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
0000121C  6100 FF6E                271      BSR         USER_INPUT_ENTER
00001220  6000 FE1C                272      BRA         PARSING_OP_CODE
00001224  4E75                     273      RTS
00001226                           274  
00001226                           275  ***
00001226                           276  * Print out the ORI to SR instruction
00001226                           277  * Unfinished implementation
00001226                           278  ***
00001226                           279  PRINT_OUT_ORI_TO_SR
00001226  43F9 00002214            280      LEA         ORI_VALUE,A1
0000122C  4EB9 000018EA            281      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001232  6100 FF58                282      BSR         USER_INPUT_ENTER
00001236  6000 FE06                283      BRA         PARSING_OP_CODE
0000123A  4E75                     284      RTS
0000123C                           285  
0000123C                           286  ***
0000123C                           287  * Print out the JSR instructions with the address to jump to
0000123C                           288  * This will print out the actual address, not just the displacement
0000123C                           289  ***
0000123C                           290  PRINT_OUT_JSR
0000123C  43F9 0000221A            291      LEA         JSR_VALUE,A1
00001242  4EB9 000018EA            292      JSR         PRINT_TO_SCREEN_ENTIRE_STRING           * Now query what type of data to print out, source or destination
00001248  4EB9 000019A6            293      JSR         PRINT_EMPTY_SPACE
0000124E  3638 0200                294      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001252  4EB9 00001A16            295      JSR         CHECK_TYPE_DATA
00001258  4EB9 000018F2            296      JSR         PRINT_DATA_MODE_SOURCE                  * Print the M and N of the last 6 bits
0000125E  6100 FF2C                297      BSR         USER_INPUT_ENTER
00001262  6000 FDDA                298      BRA         PARSING_OP_CODE
00001266                           299  
00001266                           300  ***
00001266                           301  * Print out the CMPI instruction
00001266                           302  ***
00001266                           303  PRINT_OUT_CMPI
00001266  43F9 0000222C            304      LEA         CMPI_VALUE,A1                           * Print out the literal value
0000126C  4EB9 000018EA            305      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001272  3638 0200                306      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001276  4EB9 00001A16            307      JSR         CHECK_TYPE_DATA
0000127C  4EB9 000012D4            308      JSR         PRINT_NORMAL_SUFFIX
00001282  4EB9 000019A6            309      JSR         PRINT_EMPTY_SPACE
00001288  4EB9 000019B2            310      JSR         PRINT_IMMEDIATE_DATA_SYMBOL
0000128E  4EB9 000019F4            311      JSR         GET_NORMAL_SIZE                         * Get the size of the operation to know how much byte should we advance forward
00001294  E24B                     312      LSR         #1, D3                                  * For cmpi.b and cmpi.w, they all map to absolute short in which print only 4
00001296  31C3 0550                313      MOVE.W      D3, THIRD_TEMP_VAR
0000129A  4EB9 00001A16            314      JSR         CHECK_TYPE_DATA                         * Now byte and word will be printed 4 space where as long will be printed 5 space
000012A0  4EB9 00001D76            315      JSR         REGISTER_MODE_111                       * Print out the immediate value
000012A6  4EB9 00001946            316      JSR         PRINT_COMMA
000012AC  4EB9 000019A6            317      JSR         PRINT_EMPTY_SPACE
000012B2  4EB9 000018F2            318      JSR         PRINT_DATA_MODE_SOURCE
000012B8  6100 FED2                319      BSR         USER_INPUT_ENTER
000012BC  6000 FD80                320      BRA         PARSING_OP_CODE
000012C0  4E75                     321      RTS
000012C2                           322  
000012C2                           323  ***
000012C2                           324  * Print the suffix that represent size within the opcode
000012C2                           325  * This is only used for MOVE and MOVEM instructions where the size for byte, word ,long are 01,11,10
000012C2                           326  ***
000012C2                           327  PRINT_NOT_NORMAL_SUFFIX
000012C2  49F9 00001FAC            328      LEA         NORMAL_SIZE_PRINT_JUMP_TABLE,A4
000012C8  C6FC 0006                329      MULU        #6,D3
000012CC  4EB4 3000                330      JSR         0(A4,D3)
000012D0  4243                     331      CLR         D3
000012D2  4E75                     332      RTS
000012D4                           333  
000012D4                           334  ***
000012D4                           335  * Print the suffix that represent the NORMAL size within the op code
000012D4                           336  * The normal size are usually found at the first 2 bit at the third nibble
000012D4                           337  * For byte, word, long, the size are : 00,01,10
000012D4                           338  ***
000012D4                           339  PRINT_NORMAL_SUFFIX
000012D4  3638 0200                340      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
000012D8  4EB9 000019F4            341      JSR         GET_NORMAL_SIZE
000012DE  49F9 00001FAC            342      LEA         NORMAL_SIZE_PRINT_JUMP_TABLE,A4
000012E4  B67C 0003                343      CMP         #%11,D3                                 * For normal size, does not take 11
000012E8  6700 FEAA                344      BEQ         INVALID
000012EC  C6FC 0006                345      MULU        #6,D3
000012F0  4EB4 3000                346      JSR         0(A4,D3)                                * Print out appropriate suffix
000012F4  4E75                     347      RTS
000012F6                           348  
000012F6                           349  ***
000012F6                           350  * Print out the register number (Xn)
000012F6                           351  * Need to put the register number into THIRD_TEMP_VAR first
000012F6                           352  * Could be the data source or data destination that call this method
000012F6                           353  ***
000012F6                           354  
000012F6                           355  PRINT_REGISTER_NUMBER
000012F6  49F9 00001E3E            356      LEA         HEX_CHARACTER_JUMP_TABLE,A4
000012FC  3638 0550                357      MOVE.W      THIRD_TEMP_VAR,D3
00001300  C6FC 0006                358      MULU        #6,D3
00001304  4EB4 3000                359      JSR         0(A4,D3)
00001308  4278 0550                360      CLR.W       THIRD_TEMP_VAR
0000130C  4243                     361      CLR.W       D3
0000130E  4E75                     362      RTS
00001310                           363  
00001310                           364  ***
00001310                           365  * Print out the LEA instruction
00001310                           366  ***
00001310                           367  PRINT_OUT_LEA
00001310  43F9 00002220            368      LEA         LEA_VALUE,A1
00001316  4EB9 000018EA            369      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
0000131C  4EB9 000019A6            370      JSR         PRINT_EMPTY_SPACE
00001322  3638 0200                371      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001326  4EB9 00001A16            372      JSR         CHECK_TYPE_DATA
0000132C  4EB9 000018F2            373      JSR         PRINT_DATA_MODE_SOURCE
00001332  4EB9 00001946            374      JSR         PRINT_COMMA
00001338  4EB9 000019A6            375      JSR         PRINT_EMPTY_SPACE
0000133E  4EB9 00001952            376      JSR         PRINT_ADDRESS_REGISTER                  * Already know the LEA can only take use of Address register
00001344  31F8 0250 0550           377      MOVE.W      DESTINATION_VAR,THIRD_TEMP_VAR          * Store the register number to print
0000134A  4EB8 12F6                378      JSR         PRINT_REGISTER_NUMBER
0000134E  6100 FE3C                379      BSR         USER_INPUT_ENTER
00001352  6000 FCEA                380      BRA         PARSING_OP_CODE
00001356  4E75                     381      RTS
00001358                           382  
00001358                           383  ***
00001358                           384  * Print out the ADDQ instruction
00001358                           385  * Utilized a helper method because ADDQ and SUBQ are the same
00001358                           386  ***
00001358                           387  PRINT_OUT_ADDQ
00001358  43F9 00002274            388      LEA         ADDQ_VALUE,A1
0000135E  6000 000C                389      BRA         ADDQ_AND_SUBQ_HELPER
00001362                           390  
00001362                           391  ***
00001362                           392  * Print out the SUBQ instruction
00001362                           393  * Utilized a helper method because ADDQ and SUBQ are the same
00001362                           394  ***
00001362                           395  PRINT_OUT_SUBQ
00001362  43F9 00002244            396      LEA         SUBQ_VALUE,A1
00001368  6000 0002                397      BRA         ADDQ_AND_SUBQ_HELPER
0000136C                           398  
0000136C                           399  ***
0000136C                           400  * Helper method for ADDQ and SUBQ
0000136C                           401  ***
0000136C                           402  ADDQ_AND_SUBQ_HELPER
0000136C  4EB9 000018EA            403      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001372  4EB8 12D4                404      JSR         PRINT_NORMAL_SUFFIX
00001376  4EB9 000019A6            405      JSR         PRINT_EMPTY_SPACE
0000137C  4EB9 000019B2            406      JSR         PRINT_IMMEDIATE_DATA_SYMBOL
00001382  3638 0200                407      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001386  4EB9 00001A16            408      JSR         CHECK_TYPE_DATA
0000138C  0C78 0000 0250           409      CMP         #0, DESTINATION_VAR                     * In the case of 8, the destination var is 000. But we want to print out 8
00001392  6700 0028                410      BEQ         SUBQ_HELPER_FUNCTION                    * If it is the case, then move to another helper to move 8 directly into it
00001396  31F8 0250 0550           411      MOVE.W      DESTINATION_VAR,THIRD_TEMP_VAR          * Save the value to print out from print register number
0000139C  4EB8 12F6                412      JSR         PRINT_REGISTER_NUMBER                   * Print out the data from 1-8
000013A0  4EB9 00001946            413      JSR         PRINT_COMMA
000013A6  4EB9 000019A6            414      JSR         PRINT_EMPTY_SPACE
000013AC  4EB9 000018F2            415      JSR         PRINT_DATA_MODE_SOURCE
000013B2  6100 FDD8                416      BSR         USER_INPUT_ENTER
000013B6  6000 FC86                417      BRA         PARSING_OP_CODE
000013BA  4E75                     418      RTS
000013BC                           419  
000013BC                           420  ***
000013BC                           421  * Helper method to print out 8 for ADDQ and SUBQ
000013BC                           422  ***
000013BC                           423  SUBQ_HELPER_FUNCTION                                    * Single function that exist to help with printing oout the data in SUBQ
000013BC  31FC 0008 0550           424      MOVE.W      #8, THIRD_TEMP_VAR
000013C2  4EB8 12F6                425      JSR         PRINT_REGISTER_NUMBER
000013C6  4EB9 00001946            426      JSR         PRINT_COMMA
000013CC  4EB9 000019A6            427      JSR         PRINT_EMPTY_SPACE
000013D2  4EB9 000018F2            428      JSR         PRINT_DATA_MODE_SOURCE
000013D8  6100 FDB2                429      BSR         USER_INPUT_ENTER
000013DC  6000 FC60                430      BRA         PARSING_OP_CODE
000013E0  4E75                     431      RTS
000013E2                           432  
000013E2                           433  ***
000013E2                           434  * Print out the DIVS instruction
000013E2                           435  ***
000013E2                           436  PRINT_OUT_DIVS
000013E2  43F9 0000224A            437      LEA         DIVS_VALUE,A1
000013E8  4EB9 000018EA            438      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
000013EE  4EB9 00001FD4            439      JSR         PRINT_NORMAL_WORD_SUFFIX                * DIVS can only take word suffix
000013F4  4EB9 000019A6            440      JSR         PRINT_EMPTY_SPACE
000013FA  4EB9 000018F2            441      JSR         PRINT_DATA_MODE_SOURCE
00001400  4EB9 00001946            442      JSR         PRINT_COMMA
00001406  4EB9 000019A6            443      JSR         PRINT_EMPTY_SPACE
0000140C  4EB9 0000195E            444      JSR         PRINT_DATA_REGISTER                     * DIVS can only use Data register
00001412  31F8 0250 0550           445      MOVE.W      DESTINATION_VAR, THIRD_TEMP_VAR         * Store the register number Dn to print out
00001418  4EB8 12F6                446      JSR         PRINT_REGISTER_NUMBER
0000141C  6100 FD6E                447      BSR         USER_INPUT_ENTER
00001420  6000 FC1C                448      BRA         PARSING_OP_CODE
00001424  4E75                     449      RTS
00001426                           450  
00001426                           451  ***
00001426                           452  * Print out the MULS instruction
00001426                           453  ***
00001426                           454  PRINT_OUT_MULS
00001426  43F9 0000225C            455      LEA         MULS_VALUE,A1
0000142C  6000 0002                456      BRA         MULS_AND_MULU_HELPER
00001430                           457  
00001430                           458  ***
00001430                           459  * Helper method for MULS and MULU instruction
00001430                           460  ***
00001430                           461  MULS_AND_MULU_HELPER
00001430  4EB9 000018EA            462      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001436  4EB9 00001FD4            463      JSR         PRINT_NORMAL_WORD_SUFFIX
0000143C  4EB9 000019A6            464      JSR         PRINT_EMPTY_SPACE
00001442  3638 0200                465      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001446  4EB9 00001A16            466      JSR         CHECK_TYPE_DATA
0000144C  31FC 0001 0300           467      MOVE.W      #%01, DESTINATION_MODE                  * Change the size of to word to print out
00001452  4EB9 000018F2            468      JSR         PRINT_DATA_MODE_SOURCE
00001458  4EB9 00001946            469      JSR         PRINT_COMMA
0000145E  4EB9 000019A6            470      JSR         PRINT_EMPTY_SPACE
00001464  4EB9 0000195E            471      JSR         PRINT_DATA_REGISTER
0000146A  31F8 0250 0550           472      MOVE.W      DESTINATION_VAR,THIRD_TEMP_VAR          * Save the register number
00001470  4EB8 12F6                473      JSR         PRINT_REGISTER_NUMBER
00001474  6100 FD16                474      BSR         USER_INPUT_ENTER
00001478  6000 FBC4                475      BRA         PARSING_OP_CODE
0000147C  4E75                     476      RTS
0000147E                           477  
0000147E                           478  ***
0000147E                           479  * Print out the MULU instruction
0000147E                           480  * Utilized a helper method
0000147E                           481  ***
0000147E                           482  PRINT_OUT_MULU
0000147E  43F9 00002262            483      LEA         MULU_VALUE,A1
00001484  60AA                     484      BRA         MULS_AND_MULU_HELPER
00001486                           485  
00001486                           486  ***
00001486                           487  * Print out the CMP instructions
00001486                           488  ***
00001486                           489  PRINT_OUT_CMP
00001486  43F9 00002232            490      LEA         CMP_VALUE,A1
0000148C  4EB9 000018EA            491      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001492  4EB8 12D4                492      JSR         PRINT_NORMAL_SUFFIX
00001496  4EB9 000019A6            493      JSR         PRINT_EMPTY_SPACE
0000149C  3638 0200                494      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
000014A0  4EB9 00001A16            495      JSR         CHECK_TYPE_DATA
000014A6  4EB9 000018F2            496      JSR         PRINT_DATA_MODE_SOURCE
000014AC  4EB9 00001946            497      JSR         PRINT_COMMA
000014B2  4EB9 000019A6            498      JSR         PRINT_EMPTY_SPACE
000014B8  4EB9 0000195E            499      JSR         PRINT_DATA_REGISTER                     * CMP can only use Data register
000014BE  31F8 0250 0550           500      MOVE.W      DESTINATION_VAR,THIRD_TEMP_VAR
000014C4  4EB8 12F6                501      JSR         PRINT_REGISTER_NUMBER
000014C8  6100 FCC2                502      BSR         USER_INPUT_ENTER
000014CC  6000 FB70                503      BRA         PARSING_OP_CODE
000014D0  4E75                     504      RTS
000014D2                           505  
000014D2                           506  ***
000014D2                           507  * Print out the MOVEQ instructions
000014D2                           508  ***
000014D2                           509  PRINT_OUT_MOVEQ
000014D2  43F9 000022A6            510      LEA         MOVEQ_VALUE,A1
000014D8  4EB9 000018EA            511      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
000014DE  4EB9 00001FE4            512      JSR         PRINT_NORMAL_LONG_SUFFIX                * Can only use long suffix
000014E4  3238 0200                513      MOVE.W      TEMP_CURRENT_4_NIBBLES,D1               * Save the current opcode
000014E8  4EB9 000019B2            514      JSR         PRINT_IMMEDIATE_DATA_SYMBOL
000014EE  4EB9 0000199A            515      JSR         PRINT_HEX_SYMBOL
000014F4  3638 0200                516      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
000014F8  E14B                     517      LSL         #8,D3
000014FA  E04B                     518      LSR         #8,D3
000014FC  31C3 0200                519      MOVE.W      D3, TEMP_CURRENT_4_NIBBLES              * Get the last 2 nibbles that represents that data to print out
00001500  4EB8 1128                520      JSR         CONVERT_HEX_TO_ASCII                    * Print the 8 bit data field
00001504  31C1 0200                521      MOVE.W      D1, TEMP_CURRENT_4_NIBBLES
00001508  3638 0200                522      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3               * Restore the data
0000150C  4EB9 00001946            523      JSR         PRINT_COMMA
00001512  4EB9 000019A6            524      JSR         PRINT_EMPTY_SPACE
00001518  3638 0200                525      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
0000151C  4EB9 00001A16            526      JSR         CHECK_TYPE_DATA
00001522  4EB9 0000195E            527      JSR         PRINT_DATA_REGISTER                     * Can only use Data Register
00001528  31F8 0250 0550           528      MOVE.W      DESTINATION_VAR, THIRD_TEMP_VAR         * Store the register number to print out
0000152E  4EB8 12F6                529      JSR         PRINT_REGISTER_NUMBER
00001532  6100 FC58                530      BSR         USER_INPUT_ENTER
00001536  6000 FB06                531      BRA         PARSING_OP_CODE
0000153A                           532  
0000153A                           533  ***
0000153A                           534  * Print out SUBA instruction
0000153A                           535  * Utilied a helper method
0000153A                           536  ***
0000153A                           537  PRINT_OUT_SUBA
0000153A  43F9 0000223E            538      LEA         SUBA_VALUE,A1
00001540  6000 000C                539      BRA         SUBA_AND_ADDA_HELPER
00001544                           540  
00001544                           541  ***
00001544                           542  * Print out ADDA instrucion
00001544                           543  * Utilized a helper method
00001544                           544  ***
00001544                           545  PRINT_OUT_ADDA
00001544  43F9 0000226E            546      LEA         ADDA_VALUE,A1
0000154A  6000 0002                547      BRA         SUBA_AND_ADDA_HELPER
0000154E                           548  
0000154E                           549  ***
0000154E                           550  * Helper method for ADDA ans SUBA
0000154E                           551  ***
0000154E                           552  SUBA_AND_ADDA_HELPER
0000154E  4EB9 000018EA            553      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001554  3638 0200                554      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001558  4EB9 00001A16            555      JSR         CHECK_TYPE_DATA
0000155E  4EB9 000019C4            556      JSR         GET_THE_SECOND_NIBBLE
00001564  E14B                     557      LSL         #8,D3                                   * Get the special one bit size of ADDA and SUBA
00001566  EF4B                     558      LSL         #7,D3
00001568  EE4B                     559      LSR         #7,D3
0000156A  E04B                     560      LSR         #8,D3
0000156C  5243                     561      ADD         #1,D3                                   * 0 is word and 1 is long. Add 1 will be 01 and 10, word and long for normal size
0000156E  4EB8 12C2                562      JSR         PRINT_NOT_NORMAL_SUFFIX                 * Now print .W or .L only
00001572  4EB9 000018F2            563      JSR         PRINT_DATA_MODE_SOURCE
00001578  4EB9 00001946            564      JSR         PRINT_COMMA
0000157E  4EB9 000019A6            565      JSR         PRINT_EMPTY_SPACE
00001584  4EB9 00001952            566      JSR         PRINT_ADDRESS_REGISTER
0000158A  31F8 0250 0550           567      MOVE.W      DESTINATION_VAR, THIRD_TEMP_VAR         * Save the variable to print out the number of address register
00001590  4EB8 12F6                568      JSR         PRINT_REGISTER_NUMBER
00001594  6100 FBF6                569      BSR         USER_INPUT_ENTER
00001598  6000 FAA4                570      BRA         PARSING_OP_CODE
0000159C  4E75                     571      RTS
0000159E                           572  
0000159E                           573  ***
0000159E                           574  * Print out the OR instruction
0000159E                           575  * Utilized helper method of ADD and SUB
0000159E                           576  ***
0000159E                           577  PRINT_OUT_OR
0000159E  43F9 00002294            578      LEA         OR_VALUE,A1
000015A4  6000 0016                579      BRA         ADD_AND_SUB_HELPER                      * Take advantage of the similar structure like add and sub
000015A8                           580  
000015A8                           581  ***
000015A8                           582  * Print out the ADD instruction
000015A8                           583  * Utilized a helper method
000015A8                           584  ***
000015A8                           585  PRINT_OUT_ADD           * Function similar like SUB
000015A8  43F9 00002268            586      LEA         ADD_VALUE,A1
000015AE  6000 000C                587      BRA         ADD_AND_SUB_HELPER
000015B2                           588  
000015B2                           589  ***
000015B2                           590  * Print out the SUB instructions
000015B2                           591  * Utilized a helper method
000015B2                           592  ***
000015B2                           593  PRINT_OUT_SUB
000015B2  43F9 00002238            594      LEA         SUB_VALUE,A1
000015B8  6000 0002                595      BRA         ADD_AND_SUB_HELPER
000015BC                           596  
000015BC                           597  
000015BC                           598  ***
000015BC                           599  * Helper method for SUB and ADD
000015BC                           600  * The SUB function is odd is that the Dn is always in front
000015BC                           601  * So to distinguish it, we need to check the source mode and compare wit 000
000015BC                           602  * Only time where the source and dstiantion are in correct position
000015BC                           603  * This method is when both are data register
000015BC                           604  ***
000015BC                           605  ADD_AND_SUB_HELPER
000015BC  4EB9 000018EA            606      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
000015C2  4EB8 12D4                607      JSR         PRINT_NORMAL_SUFFIX
000015C6  4EB9 000019A6            608      JSR         PRINT_EMPTY_SPACE
000015CC  3638 0200                609      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
000015D0  4EB9 00001A16            610      JSR         CHECK_TYPE_DATA
000015D6  0C78 0000 0350           611      CMP         #0, SOURCE_MODE
000015DC  6600 002E                612      BNE         SUB_HELPER_FUNCTION                         * Utilize the not normal approach
000015E0  4EB9 000018F2            613      JSR         PRINT_DATA_MODE_SOURCE
000015E6  4EB9 00001946            614      JSR         PRINT_COMMA
000015EC  4EB9 000019A6            615      JSR         PRINT_EMPTY_SPACE
000015F2  4EB9 0000195E            616      JSR         PRINT_DATA_REGISTER
000015F8  31F8 0250 0550           617      MOVE.W      DESTINATION_VAR, THIRD_TEMP_VAR
000015FE  4EB8 12F6                618      JSR         PRINT_REGISTER_NUMBER
00001602  6100 FB88                619      BSR         USER_INPUT_ENTER
00001606  6000 FA36                620      BRA         PARSING_OP_CODE
0000160A  4E75                     621      RTS
0000160C                           622  
0000160C                           623  ***
0000160C                           624  * Helper for the helper method of ADD and SUB
0000160C                           625  * Used to handle cases with data register
0000160C                           626  * For whatever the data register is always the first 3 bit of the second nibble
0000160C                           627  * Even though it can either be in the source or destination when write it
0000160C                           628  * This method is when they are not both data register
0000160C                           629  ***
0000160C                           630  SUB_HELPER_FUNCTION
0000160C  3638 0200                631      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3                   * Need to swap places to print out
00001610  4EB9 00001A16            632      JSR         CHECK_TYPE_DATA
00001616  3638 0250                633      MOVE.W      DESTINATION_VAR,D3
0000161A  31F8 0400 0250           634      MOVE.W      SOURCE_VAR,DESTINATION_VAR
00001620  31C3 0400                635      MOVE.W      D3,SOURCE_VAR
00001624  3638 0300                636      MOVE.W      DESTINATION_MODE,D3
00001628  31F8 0350 0300           637      MOVE.W      SOURCE_MODE,DESTINATION_MODE
0000162E  31C3 0350                638      MOVE.W      D3,SOURCE_MODE
00001632  3638 0350                639      MOVE.W      SOURCE_MODE, D3
00001636  31F8 0400 0550           640      MOVE.W      SOURCE_VAR, THIRD_TEMP_VAR                  * Save the variable to print out from register
0000163C  E44B                     641      LSR         #2,D3
0000163E  B67C 0000                642      CMP         #0,D3                                       * Check direction to know which order we should be printing
00001642  6700 0024                643      BEQ         SUB_HELPER_REGISTER_TO_MEM
00001646  4EB9 00001D34            644      JSR         REGISTER_MODE_000                           * Need to find a way to switch the places
0000164C  4EB9 00001946            645      JSR         PRINT_COMMA
00001652  4EB9 000019A6            646      JSR         PRINT_EMPTY_SPACE
00001658  4EB9 0000190C            647      JSR         PRINT_DATA_MODE_DESTINATION
0000165E  6100 FB2C                648      BSR         USER_INPUT_ENTER
00001662  6000 F9DA                649      BRA         PARSING_OP_CODE
00001666  4E75                     650      RTS
00001668                           651  
00001668                           652  ***
00001668                           653  * Helper method to help with printing from register to memory
00001668                           654  ***
00001668                           655  SUB_HELPER_REGISTER_TO_MEM
00001668  4EB9 0000190C            656      JSR         PRINT_DATA_MODE_DESTINATION
0000166E  4EB9 00001946            657      JSR         PRINT_COMMA
00001674  4EB9 000019A6            658      JSR         PRINT_EMPTY_SPACE
0000167A  4EB9 00001D34            659      JSR         REGISTER_MODE_000
00001680  6100 FB0A                660      BSR         USER_INPUT_ENTER
00001684  6000 F9B8                661      BRA         PARSING_OP_CODE
00001688  4E75                     662      RTS
0000168A                           663  
0000168A                           664  ***
0000168A                           665  * Print out the BRA instruction
0000168A                           666  * Current limitation: Only can print out branch to a word address (4bytes).No support for 8 bytes
0000168A                           667  ***
0000168A                           668  PRINT_OUT_BRA
0000168A  43F9 00002250            669      LEA         BRA_VALUE,A1
00001690  4EB9 000018EA            670      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001696  4EB9 000019A6            671      JSR         PRINT_EMPTY_SPACE
0000169C  4EB9 0000199A            672      JSR         PRINT_HEX_SYMBOL
000016A2  380A                     673      MOVE.W      A2,D4                                       * Save the current address we are at
000016A4  4EB9 000019DE            674      JSR         GET_NEXT_FOUR_NIBBLE                        * Get the displacement we are suppose to branch to
000016AA  D843                     675      ADD         D3,D4                                       * Current address + displacement => address we are suppose to jump to
000016AC  31C4 0200                676      MOVE.W      D4, TEMP_CURRENT_4_NIBBLES                  * Prepare the address to print out in hex
000016B0  4EB8 1128                677      JSR         CONVERT_HEX_TO_ASCII
000016B4  6100 FAD6                678      BSR         USER_INPUT_ENTER
000016B8  6000 F984                679      BRA         PARSING_OP_CODE
000016BC                           680  
000016BC                           681  ***
000016BC                           682  * Print out the BSR instruction
000016BC                           683  * limitation: Same like BRA
000016BC                           684  ***
000016BC                           685  PRINT_OUT_BSR
000016BC  43F9 00002256            686      LEA         BSR_VALUE,A1
000016C2  4EB9 000018EA            687      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
000016C8  4EB9 000019A6            688      JSR         PRINT_EMPTY_SPACE
000016CE  4EB9 0000199A            689      JSR         PRINT_HEX_SYMBOL
000016D4  380A                     690      MOVE.W      A2,D4
000016D6  4EB9 000019DE            691      JSR         GET_NEXT_FOUR_NIBBLE
000016DC  D843                     692      ADD         D3,D4
000016DE  31C4 0200                693      MOVE.W      D4,TEMP_CURRENT_4_NIBBLES
000016E2  4EB8 1128                694      JSR         CONVERT_HEX_TO_ASCII
000016E6  6100 FAA4                695      BSR         USER_INPUT_ENTER
000016EA  6000 F952                696      BRA         PARSING_OP_CODE
000016EE                           697  
000016EE                           698  ***
000016EE                           699  * Print out the appropriate Bcc instruction using a jump table
000016EE                           700  ***
000016EE                           701  PRINT_OUT_Bcc
000016EE  43F9 00002332            702      LEA         B,A1
000016F4  4EB9 000018EA            703      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
000016FA  4DF9 00001FFA            704      LEA         CONDITION_JUMP_TABLE,A6                     * Load the jump table to know which condition code to print
00001700  3638 0200                705      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001704  4EB9 000019C4            706      JSR         GET_THE_SECOND_NIBBLE
0000170A  C6FC 0006                707      MULU        #6,D3
0000170E  4EB6 3000                708      JSR         0(A6,D3)                                    * Now print out the suffix of B
00001712  4EB9 000019A6            709      JSR         PRINT_EMPTY_SPACE
00001718  4EB9 0000199A            710      JSR         PRINT_HEX_SYMBOL
0000171E  380A                     711      MOVE.W      A2,D4                                       * Print out the address
00001720  4EB9 000019DE            712      JSR         GET_NEXT_FOUR_NIBBLE
00001726  D843                     713      ADD         D3,D4
00001728  31C4 0200                714      MOVE.W      D4,TEMP_CURRENT_4_NIBBLES
0000172C  4EB8 1128                715      JSR         CONVERT_HEX_TO_ASCII
00001730  6100 FA5A                716      BSR         USER_INPUT_ENTER
00001734  6000 F908                717      BRA         PARSING_OP_CODE
00001738                           718  
00001738                           719  ***
00001738                           720  * Logical Shift instruction with single operand memory <ea>
00001738                           721  ***
00001738                           722  PRINT_OUT_LOGICAL_SHIFT_MEM
00001738  43F9 0000227E            723      LEA         LS_VALUE,A1
0000173E  4EB9 00001754            724      JSR         ASD_LSD_ROD_SHIFT_HELPER
00001744  4E75                     725      RTS
00001746                           726  
00001746                           727  ***
00001746                           728  * Arithmeic shift instruction with single operand memory <ea>
00001746                           729  ***
00001746                           730  PRINT_OUT_ARITH_SHIFT_MEM
00001746  43F9 0000227A            731      LEA         AS_VALUE,A1
0000174C  4EB9 00001754            732      JSR         ASD_LSD_ROD_SHIFT_HELPER
00001752  4E75                     733      RTS
00001754                           734  
00001754                           735  ***
00001754                           736  * Helper method for ASd, LSd, ROd
00001754                           737  ***
00001754                           738  ASD_LSD_ROD_SHIFT_HELPER
00001754  4EB9 000018EA            739      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
0000175A  4DF9 000020CA            740      LEA         RIGHT_OR_LEFT_JUMP_TABLE,A6                 * Print the direction, left or right
00001760  3638 0200                741      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001764  4EB9 00001A16            742      JSR         CHECK_TYPE_DATA
0000176A  4EB9 000019C4            743      JSR         GET_THE_SECOND_NIBBLE
00001770  E14B                     744      LSL         #8,D3
00001772  EF4B                     745      LSL         #7,D3
00001774  EE4B                     746      LSR         #7,D3
00001776  E04B                     747      LSR         #8,D3
00001778  C6FC 0006                748      MULU        #6,D3
0000177C  4EB6 3000                749      JSR         0(A6,D3)                                    * Print out left or right
00001780  4EB9 00001FD4            750      JSR         PRINT_NORMAL_WORD_SUFFIX
00001786  31F8 0400 0550           751      MOVE.W      SOURCE_VAR, THIRD_TEMP_VAR                  * Save the register number in case for print OUT
0000178C  4EB9 000018F2            752      JSR         PRINT_DATA_MODE_SOURCE
00001792  6100 F9F8                753      BSR         USER_INPUT_ENTER
00001796  6000 F8A6                754      BRA         PARSING_OP_CODE
0000179A  4E75                     755      RTS
0000179C                           756  
0000179C                           757  ***
0000179C                           758  * Print out the ROd instruction with operand memory <ea>
0000179C                           759  ***
0000179C                           760  PRINT_OUT_ROTATE_MEM
0000179C  43F9 00002282            761      LEA         RO_VALUE,A1
000017A2  4EB8 1754                762      JSR         ASD_LSD_ROD_SHIFT_HELPER
000017A6  4E75                     763      RTS
000017A8                           764  
000017A8                           765  ***
000017A8                           766  * print out the ASd and LSd with other cases
000017A8                           767  * ASL Dx, Dy for example
000017A8                           768  * ASL #<data>, Dy
000017A8                           769  ***
000017A8                           770  PRINT_OUT_ASD_OR_LSD                                * For other ASd and LSd, the first  bit of the last nibble can be used to differentiate them
000017A8  3638 0200                771      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
000017AC  4EB9 000019D4            772      JSR         GET_THE_FOURTH_NIBBLE
000017B2  E64B                     773      LSR         #3,D3
000017B4  B67C 0000                774      CMP         #0,D3
000017B8  6700 0008                775      BEQ         PRINT_OUT_ASD                       * First bit is 0 for ASD
000017BC  6000 0012                776      BRA         PRINT_OUT_LSD                       * 1 for LSD
000017C0  4E75                     777      RTS
000017C2                           778  
000017C2                           779  ***
000017C2                           780  * Print out the ASD instruction with other cases
000017C2                           781  * ASL Dx, Dy
000017C2                           782  * ASL #<data>, Dy
000017C2                           783  ***
000017C2                           784  PRINT_OUT_ASD
000017C2  43F9 0000227A            785      LEA         AS_VALUE,A1
000017C8  4EB9 00001800            786      JSR         ASD_LSD_ROD_HELPER_FUNCTION
000017CE  4E75                     787      RTS
000017D0                           788  
000017D0                           789  ***
000017D0                           790  * Print out the LSd instruction with other cases
000017D0                           791  * LSR Dx, Dy
000017D0                           792  * LSR #<data>, Dy
000017D0                           793  ***
000017D0                           794  PRINT_OUT_LSD
000017D0  43F9 0000227E            795      LEA         LS_VALUE,A1
000017D6  4EB9 00001800            796      JSR         ASD_LSD_ROD_HELPER_FUNCTION
000017DC  4E75                     797      RTS
000017DE                           798  
000017DE                           799  ***
000017DE                           800  * Print out the ROd instruction with other cases
000017DE                           801  * ROL Dx, Dy
000017DE                           802  * ROL #<data>, Dy
000017DE                           803  ***
000017DE                           804  PRINT_OUT_ROD
000017DE  3638 0200                805      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
000017E2  4EB9 000019D4            806      JSR         GET_THE_FOURTH_NIBBLE
000017E8  E64B                     807      LSR         #3,D3
000017EA  B67C 0001                808      CMP         #1,D3
000017EE  6600 F9A4                809      BNE         INVALID                                     * ROD ibly accept 1 as the first bit in the fourth nibbles
000017F2  43F9 00002282            810      LEA         RO_VALUE,A1
000017F8  4EB9 00001800            811      JSR         ASD_LSD_ROD_HELPER_FUNCTION
000017FE  4E75                     812      RTS
00001800                           813  
00001800                           814  ***
00001800                           815  * ASd, LSd, ROd instruction with other cases with 2 operands source and destionation
00001800                           816  ***
00001800                           817  ASD_LSD_ROD_HELPER_FUNCTION   *
00001800  4EB9 000018EA            818      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001806  4DF9 000020CA            819      LEA         RIGHT_OR_LEFT_JUMP_TABLE,A6                 * Print the direction, left or right
0000180C  3638 0200                820      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001810  4EB9 00001A16            821      JSR         CHECK_TYPE_DATA
00001816  4EB9 000019C4            822      JSR         GET_THE_SECOND_NIBBLE
0000181C  E14B                     823      LSL         #8,D3
0000181E  EF4B                     824      LSL         #7,D3
00001820  E04B                     825      LSR         #8,D3
00001822  EE4B                     826      LSR         #7,D3
00001824  C6FC 0006                827      MULU        #6,D3
00001828  4EB6 3000                828      JSR         0(A6,D3)                                    * Print out left or right
0000182C  3638 0200                829      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001830  4EB8 12D4                830      JSR         PRINT_NORMAL_SUFFIX                         * Print out .B, .W or .L
00001834  3638 0200                831      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3                   * Now we need to determine if its is immediate or register rotation
00001838  4EB9 000019CC            832      JSR         GET_THE_THIRD_NIBBLE
0000183E  E14B                     833      LSL         #8,D3
00001840  ED4B                     834      LSL         #6,D3
00001842  E04B                     835      LSR         #8,D3
00001844  EE4B                     836      LSR         #7,D3                                       * Now the third bit will be at the last position
00001846  4DF9 000020EE            837      LEA         IMMEDIATE_OR_REGISTER_JUMP_TABLE,A6
0000184C  C6FC 0006                838      MULU        #6,D3
00001850  4EB6 3000                839      JSR         0(A6,D3)
00001854  4EB9 0000195E            840      JSR         PRINT_DATA_REGISTER
0000185A  3638 0200                841      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
0000185E  4EB9 00001A16            842      JSR         CHECK_TYPE_DATA
00001864  31F8 0400 0550           843      MOVE.W      SOURCE_VAR,THIRD_TEMP_VAR                   * Save the register number to print out
0000186A  4EB8 12F6                844      JSR         PRINT_REGISTER_NUMBER
0000186E  6100 F91C                845      BSR         USER_INPUT_ENTER
00001872  6000 F7CA                846      BRA         PARSING_OP_CODE
00001876  4E75                     847      RTS
00001878                           848  
00001878                           849  ***
00001878                           850  *  Decide whether to print move or move a based the 3 bit at the destination mode
00001878                           851  ***
00001878                           852  MOVE_OPCODE_HELPER
00001878  3638 0200                853      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
0000187C  4EB9 00001A16            854      JSR         CHECK_TYPE_DATA
00001882  0C78 0001 0300           855      CMP         #%001, DESTINATION_MODE
00001888  6700 0008                856      BEQ         PRINT_OUT_MOVEA
0000188C  6000 0010                857      BRA         PRINT_OUT_MOVE
00001890  4E75                     858      RTS
00001892                           859  
00001892                           860  ***
00001892                           861  * Print out MOVEA
00001892                           862  * UTilized a helper method
00001892                           863  ***
00001892                           864  PRINT_OUT_MOVEA
00001892  43F9 00002298            865      LEA         MOVEA_VALUE,A1
00001898  4EB9 000018AA            866      JSR         MOVE_SECOND_OPCODE_HELPER
0000189E                           867  
0000189E                           868  ***
0000189E                           869  * Print out MOVE
0000189E                           870  * Utlized a helper method
0000189E                           871  ***
0000189E                           872  PRINT_OUT_MOVE
0000189E  43F9 000022A0            873      LEA         MOVE_VALUE,A1
000018A4  4EB9 000018AA            874      JSR         MOVE_SECOND_OPCODE_HELPER
000018AA                           875  
000018AA                           876  ***
000018AA                           877  * Helper method for MOVE and MOVEA
000018AA                           878  ***
000018AA                           879  MOVE_SECOND_OPCODE_HELPER
000018AA  4EB9 000018EA            880      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
000018B0  4DF9 00001F5E            881      LEA         MOVE_SIZE_PRINT_JUMP_TABLE,A6                   * Special size for move instruction
000018B6  3638 0200                882      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
000018BA  4EB9 000019BE            883      JSR         GET_THE_FIRST_NIBBLE
000018C0  C6FC 0006                884      MULU        #6,D3
000018C4  4EB6 3000                885      JSR         0(A6,D3)
000018C8  4EB9 000018F2            886      JSR         PRINT_DATA_MODE_SOURCE
000018CE  4EB9 00001946            887      JSR         PRINT_COMMA
000018D4  4EB9 000019A6            888      JSR         PRINT_EMPTY_SPACE
000018DA  4EB9 0000190C            889      JSR         PRINT_DATA_MODE_DESTINATION
000018E0  6100 F8AA                890      BSR         USER_INPUT_ENTER
000018E4  6000 F758                891      BRA         PARSING_OP_CODE
000018E8  4E75                     892      RTS
000018EA                           893  
000018EA                           894  ***
000018EA                           895  * Print whatever is stored in A1
000018EA                           896  ***
000018EA                           897  PRINT_TO_SCREEN_ENTIRE_STRING
000018EA  103C 000E                898      MOVE.B      #14,D0
000018EE  4E4F                     899      TRAP        #15
000018F0  4E75                     900      RTS
000018F2                           901  
000018F2                           902  ***
000018F2                           903  * Print the data containeds at the last 6 bit of op code
000018F2                           904  * Destionation var - destionation mode- source mode - source var
000018F2                           905  ***
000018F2                           906  PRINT_DATA_MODE_SOURCE         * Depnding on the mode, will print out appropriate data mode: Dn,An,(An),...
000018F2  4DF9 00001D04            907      LEA         REGISTER_MODE_JUMP_TABLE,A6
000018F8  31F8 0400 0550           908      MOVE.W      SOURCE_VAR, THIRD_TEMP_VAR
000018FE  3638 0350                909      MOVE        SOURCE_MODE,D3
00001902  C6FC 0006                910      MULU        #6,D3
00001906  4EB6 3000                911      JSR         0(A6,D3)       * Let's see what mode is this source mode
0000190A  4E75                     912      RTS
0000190C                           913  ***
0000190C                           914  * Print the data contains in the 12-7 bit of op code
0000190C                           915  * Destionation var - destionation mode - source mode - source var
0000190C                           916  ***
0000190C                           917  PRINT_DATA_MODE_DESTINATION
0000190C  4DF9 00001D04            918      LEA         REGISTER_MODE_JUMP_TABLE,A6
00001912  31F8 0250 0550           919      MOVE.W      DESTINATION_VAR, THIRD_TEMP_VAR             * Determine the Xn to print
00001918  3638 0300                920      MOVE.W      DESTINATION_MODE,D3
0000191C  C6FC 0006                921      MULU        #6,D3
00001920  4EB6 3000                922      JSR         0(A6,D3)
00001924  4E75                     923      RTS
00001926                           924  
00001926                           925  ***
00001926                           926  * Print out the address in which we are executing the disassembli
00001926                           927  * Should print out 00XX YYYY as the address location
00001926                           928  ***
00001926                           929  PRINT_ADDRESS_LOCATION
00001926  2A0A                     930      MOVE.L      A2,D5 * Save the address we are at
00001928  E04D                     931      LSR         #8,D5                                       * Shift 4 bytes left most to print out
0000192A  E04D                     932      LSR         #8,D5
0000192C  31C5 0200                933      MOVE.W      D5,TEMP_CURRENT_4_NIBBLES                   * Get the entire long address
00001930  4EB8 1128                934      JSR         CONVERT_HEX_TO_ASCII
00001934  3A0A                     935      MOVE.W      A2,D5
00001936  31C5 0200                936      MOVE.W      D5,TEMP_CURRENT_4_NIBBLES
0000193A  4EB8 1128                937      JSR         CONVERT_HEX_TO_ASCII
0000193E  4EB9 000019A6            938      JSR         PRINT_EMPTY_SPACE
00001944  4E75                     939      RTS
00001946                           940  
00001946                           941  ***
00001946                           942  * Print ','
00001946                           943  ***
00001946                           944  PRINT_COMMA
00001946  43F9 000022E6            945      LEA         COMMA,A1
0000194C  4EB8 18EA                946      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001950  4E75                     947      RTS
00001952                           948  
00001952                           949  ***
00001952                           950  * Print 'A'
00001952                           951  ***
00001952                           952  PRINT_ADDRESS_REGISTER
00001952  43F9 000022E2            953      LEA         ADDRESS_REGISTER,A1
00001958  4EB8 18EA                954      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
0000195C  4E75                     955      RTS
0000195E                           956  
0000195E                           957  ***
0000195E                           958  * Print 'D'
0000195E                           959  ***
0000195E                           960  PRINT_DATA_REGISTER
0000195E  43F9 000022DE            961      LEA         DATA_REGISTER,A1
00001964  4EB8 18EA                962      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001968  4E75                     963      RTS
0000196A                           964  
0000196A                           965  ***
0000196A                           966  * Print '('
0000196A                           967  ***
0000196A                           968  PRINT_OPEN_BRACKET
0000196A  43F9 000022CE            969      LEA         OPENING_BRACKET,A1
00001970  4EB8 18EA                970      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001974  4E75                     971      RTS
00001976                           972  
00001976                           973  ***
00001976                           974  * Print ')'
00001976                           975  ***
00001976                           976  PRINT_CLOSE_BRACKET
00001976  43F9 000022D2            977      LEA         CLOSING_BRACKET,A1
0000197C  4EB8 18EA                978      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001980  4E75                     979      RTS
00001982                           980  
00001982                           981  ***
00001982                           982  * Print '+'
00001982                           983  ***
00001982                           984  PRINT_PLUS_SIGN
00001982  43F9 000022D6            985      LEA         PLUS_SIGN,A1
00001988  4EB8 18EA                986      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
0000198C  4E75                     987      RTS
0000198E                           988  
0000198E                           989  ***
0000198E                           990  * Print '-'
0000198E                           991  ***
0000198E                           992  PRINT_MINUS_SIGN
0000198E  43F9 000022DA            993      LEA         MINUS_SIGN,A1
00001994  4EB8 18EA                994      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001998  4E75                     995      RTS
0000199A                           996  
0000199A                           997  ***
0000199A                           998  * print '$'
0000199A                           999  ***
0000199A                          1000  PRINT_HEX_SYMBOL
0000199A  43F9 000022F2           1001      LEA         HEX_SYMBOL,A1
000019A0  4EB8 18EA               1002      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
000019A4  4E75                    1003      RTS
000019A6                          1004  
000019A6                          1005  ***
000019A6                          1006  * Print ' '
000019A6                          1007  ***
000019A6                          1008  PRINT_EMPTY_SPACE
000019A6  43F9 000022EA           1009      LEA         SPACE,A1
000019AC  4EB8 18EA               1010      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
000019B0  4E75                    1011      RTS
000019B2                          1012  
000019B2                          1013  ***
000019B2                          1014  * Print '#'
000019B2                          1015  ***
000019B2                          1016  PRINT_IMMEDIATE_DATA_SYMBOL
000019B2  43F9 000022F6           1017      LEA         IMMEDIATE_DATA_SYMBOL,A1
000019B8  4EB8 18EA               1018      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
000019BC  4E75                    1019      RTS
000019BE                          1020  
000019BE                          1021  *******************************************************************************
000019BE                          1022  ***************************************
000019BE                          1023  * Query data section
000019BE                          1024  * Contains utility methods
000019BE                          1025  ***************************************
000019BE                          1026  *******************************************************************************
000019BE                          1027  
000019BE                          1028  ***
000019BE                          1029  * Get the left most byte. Assuming that the full word data is already store in D3
000019BE                          1030  ***
000019BE                          1031  GET_THE_FIRST_NIBBLE
000019BE  E04B                    1032      LSR         #8,D3                               * Shift 2 bytes to the rights
000019C0  E84B                    1033      LSR         #4,D3                               * Shift 1 byte to the right. Now left most byte is now the right most byte
000019C2  4E75                    1034      RTS
000019C4                          1035  
000019C4                          1036  ***
000019C4                          1037  * Get the second nibble from the left
000019C4                          1038  ***
000019C4                          1039  GET_THE_SECOND_NIBBLE
000019C4  E94B                    1040      LSL         #4,D3                               * Shift the left most byte to go away
000019C6  E84B                    1041      LSR         #4,D3                               * Return the original place
000019C8  E04B                    1042      LSR         #8,D3                               * Push the 2 right most byte out of the way
000019CA  4E75                    1043      RTS
000019CC                          1044  
000019CC                          1045  ***
000019CC                          1046  * Get the third nibble from the left
000019CC                          1047  ***
000019CC                          1048  GET_THE_THIRD_NIBBLE
000019CC  E14B                    1049      LSL         #8,D3                               * Bye byte 2 left most nibble
000019CE  E04B                    1050      LSR         #8,D3                               * Get rid of the 3 bytes that are infront
000019D0  E84B                    1051      LSR         #4,D3                               * Shift back to original position
000019D2  4E75                    1052      RTS
000019D4                          1053  
000019D4                          1054  ***
000019D4                          1055  * Get the fourth nibble from the left
000019D4                          1056  ***
000019D4                          1057  GET_THE_FOURTH_NIBBLE
000019D4  E14B                    1058      LSL         #8,D3
000019D6  E94B                    1059      LSL         #4,D3
000019D8  E04B                    1060      LSR         #8,D3
000019DA  E84B                    1061      LSR         #4,D3
000019DC  4E75                    1062      RTS
000019DE                          1063  
000019DE                          1064  ***
000019DE                          1065  * Advance 2 bytes for Word ( 4 nibbles)
000019DE                          1066  ***
000019DE                          1067  GET_NEXT_FOUR_NIBBLE
000019DE  361A                    1068      MOVE.W      (A2)+,D3
000019E0  31C3 0200               1069      MOVE.W      D3, TEMP_CURRENT_4_NIBBLES          * Copy the value into temp variable
000019E4  B7CA                    1070      CMPA.L      A2,A3                               * Check the starting and ending address if we have surpass it
000019E6  6F00 0020               1071      BLE         FINISH_DISASSEMBLING
000019EA  4E75                    1072      RTS
000019EC                          1073  
000019EC                          1074  ***
000019EC                          1075  * Advance 1 byte for word (2 nibbles)
000019EC                          1076  ***
000019EC                          1077  GET_NEXT_TWO_NIBBLE
000019EC  161A                    1078      MOVE.B      (A2)+,D3                            * Get the next byte ( 2 nibbles)
000019EE  11C3 0750               1079      MOVE.B      D3, TEMP_CURRENT_2_NIBBLES
000019F2  4E75                    1080      RTS
000019F4                          1081  
000019F4                          1082  ***
000019F4                          1083  * Get the normal size in the opcode, usually the first 2 bit of the third nibble
000019F4                          1084  ***
000019F4                          1085  GET_NORMAL_SIZE
000019F4  4EB9 00001A16           1086      JSR         CHECK_TYPE_DATA
000019FA  3638 0300               1087      MOVE.W      DESTINATION_MODE,D3
000019FE  E14B                    1088      LSL         #8,D3
00001A00  ED4B                    1089      LSL         #6,D3
00001A02  E04B                    1090      LSR         #8,D3
00001A04  EC4B                    1091      LSR         #6,D3
00001A06  4E75                    1092      RTS
00001A08                          1093  
00001A08                          1094  ***
00001A08                          1095  * Display prompt saying that it has finished disassembling
00001A08                          1096  ***
00001A08                          1097  FINISH_DISASSEMBLING
00001A08  43F9 000021BA           1098      LEA         FINISH,A1
00001A0E  4EB8 18EA               1099      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001A12  FFFF FFFF               1100      SIMHALT
00001A16                          1101  
00001A16                          1102  *******************************************************************************
00001A16                          1103  * logical reasoning section (determine what kind of opcode to print, what type of data to print)
00001A16                          1104  *******************************************************************************
00001A16                          1105  
00001A16                          1106  
00001A16                          1107  ***
00001A16                          1108  * getting the appropriate source and destination register  and mode
00001A16                          1109  * Destionation var - destionation mode - source mode - soruce var
00001A16                          1110  ***
00001A16                          1111  CHECK_TYPE_DATA
00001A16  3638 0200               1112      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001A1A  E94B                    1113      LSL         #4,D3                               * Get rid of left most byte
00001A1C  E84B                    1114      LSR         #4,D3                               * Now focus on the following format      destination mode mode source. Start with destination first
00001A1E  E04B                    1115      LSR         #8,D3                               * Now the D3 has the destination
00001A20  E24B                    1116      LSR         #1,D3
00001A22  31C3 0250               1117      MOVE.W      D3,DESTINATION_VAR
00001A26  3638 0200               1118      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3           * Now go with the destination mode
00001A2A  EF4B                    1119      LSL         #7,D3
00001A2C  EE4B                    1120      LSR         #7,D3
00001A2E  EC4B                    1121      LSR         #6,D3
00001A30  31C3 0300               1122      MOVE.W      D3,DESTINATION_MODE
00001A34  3638 0200               1123      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3           * Now extract the source mode
00001A38  E14B                    1124      LSL         #8,D3
00001A3A  E54B                    1125      LSL         #2,D3
00001A3C  E04B                    1126      LSR         #8,D3
00001A3E  E44B                    1127      LSR         #2,D3
00001A40  E64B                    1128      LSR         #3,D3
00001A42  31C3 0350               1129      MOVE.W      D3,SOURCE_MODE                      * Now extract the source
00001A46  3638 0200               1130      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001A4A  E14B                    1131      LSL         #8,D3
00001A4C  EB4B                    1132      LSL         #5,D3
00001A4E  E04B                    1133      LSR         #8,D3
00001A50  EA4B                    1134      LSR         #5,D3
00001A52  31C3 0400               1135      MOVE.W      D3,SOURCE_VAR
00001A56  3638 0200               1136      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001A5A  4E75                    1137      RTS
00001A5C                          1138  
00001A5C                          1139  ***
00001A5C                          1140  * Reasoning section for NOP, JSR, RTS
00001A5C                          1141  ***
00001A5C                          1142  FIRST_NIBBLE_4_SECOND_NIBBLE_E
00001A5C  3638 0200               1143      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001A60  E14B                    1144      LSL         #8,D3                               * Shift to the left to dissappear 2 left most byte
00001A62  E04B                    1145      LSR         #8,D3                               * Shift to the right to gain back original position. Only now the 2 left most byte are gone
00001A64  B63C 0071               1146      CMP.B       #$71,D3                             * NOP is 4E71
00001A68  6700 F792               1147      BEQ         PRINT_OUT_NOP
00001A6C  B63C 0075               1148      CMP.B       #$75,D3                             *RTS is 4E75
00001A70  6700 F79E               1149      BEQ         PRINT_OUT_RTS
00001A74  3638 0200               1150      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001A78  4EB8 1A16               1151      JSR         CHECK_TYPE_DATA                     *  Get the destination mode and desitnation register. Could be JSR
00001A7C  3638 0200               1152      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001A80  4EB8 19CC               1153      JSR         GET_THE_THIRD_NIBBLE                * For Jsr  the 2 bit of the 3rd nibble is 10
00001A84  E44B                    1154      LSR         #2, D3
00001A86  B67C 0002               1155      CMP         #%10, D3
00001A8A  6700 F7B0               1156      BEQ         PRINT_OUT_JSR                       * Print out the command JSR and the data
00001A8E  6000 F704               1157      BRA         INVALID
00001A92  4E75                    1158      RTS
00001A94                          1159  
00001A94                          1160  ********************************************************************************
00001A94                          1161  * Specific branching of the jump table is stored here
00001A94                          1162  *******************************************************************************
00001A94                          1163  FIRST_NIBBLE_JUMP_TABLE                  * Based on the first byte of the op code then jump on what is possible
00001A94  4EF9 00001AF4           1164      JMP         FIRST_NIBBLE_IS_0               * ORI, CMPI. BCLR
00001A9A  4EF9 00001B0A           1165      JMP         FIRST_NIBBLE_IS_1               * MOVE.B, MOVEA.B
00001AA0  4EF9 00001B12           1166      JMP         FIRST_NIBBLE_IS_2               * MOVEA.L, MOVE.L
00001AA6  4EF9 00001B1A           1167      JMP         FIRST_NIBBLE_IS_3               * MOVE.W    MOVEA.W
00001AAC  4EF9 00001B22           1168      JMP         FIRST_NIBBLE_IS_4               * NOP, LEA, NEG, JSR, RTS
00001AB2  4EF9 00001B52           1169      JMP         FIRST_NIBBLE_IS_5               * SUBQ
00001AB8  4EF9 00001B88           1170      JMP         FIRST_NIBBLE_IS_6               * BCS, BGE, BLT, BVC, BRA
00001ABE  4EF9 00001BAA           1171      JMP         FIRST_NIBBLE_IS_7               * NOT SUPPORTED
00001AC4  4EF9 00001BCA           1172      JMP         FIRST_NIBBLE_IS_8               * DIVS, OR
00001ACA  4EF9 00001BF0           1173      JMP         FIRST_NIBBLE_IS_9               * SUB
00001AD0  4EF9 00001C0C           1174      JMP         FIRST_NIBBLE_IS_A               * NOT SUPPORTED
00001AD6  4EF9 00001C14           1175      JMP         FIRST_NIBBLE_IS_B               * EOR, CMP
00001ADC  4EF9 00001C48           1176      JMP         FIRST_NIBBLE_IS_C               * MULS
00001AE2  4EF9 00001C7E           1177      JMP         FIRST_NIBBLE_IS_D               * ADD, ADDA
00001AE8  4EF9 00001C9C           1178      JMP         FIRST_NIBBLE_IS_E               * LSR, LSL, ASR, ASL, ROL, ROR
00001AEE  4EF9 00001CD2           1179      JMP         FIRST_NIBBLE_IS_F               * NOT SUPPORTED
00001AF4                          1180  
00001AF4                          1181  FIRST_NIBBLE_IS_0
00001AF4  3638 0200               1182      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001AF8  4EB8 19C4               1183      JSR         GET_THE_SECOND_NIBBLE
00001AFC  B67C 000C               1184      CMP         #$C, D3
00001B00  6700 F764               1185      BEQ         PRINT_OUT_CMPI
00001B04  6000 F68E               1186      BRA         INVALID
00001B08  4E75                    1187      RTS
00001B0A                          1188  
00001B0A                          1189  
00001B0A                          1190  FIRST_NIBBLE_IS_1 *MOVE.B, MOVEA.B * Can only be MOVE for these nibble because of the size of MOVE
00001B0A  4EB8 1878               1191      JSR         MOVE_OPCODE_HELPER
00001B0E  FFFF FFFF               1192      SIMHALT
00001B12                          1193  
00001B12                          1194  FIRST_NIBBLE_IS_2 *MOVE.L, MOVEA.L
00001B12  4EB8 1878               1195      JSR         MOVE_OPCODE_HELPER
00001B16  FFFF FFFF               1196      SIMHALT
00001B1A                          1197  
00001B1A                          1198  FIRST_NIBBLE_IS_3 * MOVE.W, MOVEA.W
00001B1A  4EB8 1878               1199      JSR         MOVE_OPCODE_HELPER
00001B1E  FFFF FFFF               1200      SIMHALT
00001B22                          1201  
00001B22                          1202  FIRST_NIBBLE_IS_4                                       * Possible for NOP,LEA,RTS,JSR,NEG. Now will check the second byte
00001B22  3638 0200               1203      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3               * Get the original op code back
00001B26  4EB8 19C4               1204      JSR         GET_THE_SECOND_NIBBLE
00001B2A  B63C 000E               1205      CMP.B       #$E,D3
00001B2E  6700 FF2C               1206      BEQ         FIRST_NIBBLE_4_SECOND_NIBBLE_E          * NOP,RTS,JSR
00001B32  B63C 0004               1207      CMP.B       #4,D3                                   *If the second nibble is 4, then it must be neg
00001B36  6700 F68A               1208      BEQ         PRINT_OUT_NEG
00001B3A  3638 0200               1209      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001B3E  4EB8 1A16               1210      JSR         CHECK_TYPE_DATA
00001B42  0C78 0007 0300          1211      CMP         #%111,DESTINATION_MODE
00001B48  6700 F7C6               1212      BEQ         PRINT_OUT_LEA                           * Only LEA have the 3 bits of destination is 111
00001B4C  6000 F646               1213      BRA         INVALID
00001B50  4E75                    1214      RTS
00001B52                          1215  
00001B52                          1216  FIRST_NIBBLE_IS_5                                       * This is SUBQ and ADDQ
00001B52  3638 0200               1217      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001B56  4EB8 1A16               1218      JSR         CHECK_TYPE_DATA
00001B5A  4EB8 19F4               1219      JSR         GET_NORMAL_SIZE                         * SUBQ and ADDQ only accpet normal size. Meaning no 11
00001B5E  B67C 0003               1220      CMP         #%11,D3
00001B62  6700 F630               1221      BEQ         INVALID
00001B66  3638 0200               1222      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001B6A  4EB8 19C4               1223      JSR         GET_THE_SECOND_NIBBLE
00001B6E  E14B                    1224      LSL         #8,D3                                   * Get rid of the first 2 byets
00001B70  EF4B                    1225      LSL         #7,D3                                   * Shift back to original position
00001B72  E04B                    1226      LSR         #8,D3
00001B74  EE4B                    1227      LSR         #7,D3
00001B76  B67C 0000               1228      CMP         #0,D3                                   * SUBQ have 1 as the last bit in the second nibble
00001B7A  6700 F7DC               1229      BEQ         PRINT_OUT_ADDQ                          * ADDQ has 0 as the last bit in the second nibble
00001B7E  6000 F7E2               1230      BRA         PRINT_OUT_SUBQ
00001B82  4E75                    1231      RTS
00001B84  FFFF FFFF               1232      SIMHALT
00001B88                          1233  
00001B88                          1234  FIRST_NIBBLE_IS_6                                       * Bcc and BRA , BSR
00001B88  3638 0200               1235      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001B8C  4EB8 19C4               1236      JSR         GET_THE_SECOND_NIBBLE
00001B90  B67C 0000               1237      CMP         #%0000,D3                               * Only the condition code of BRA is 0000
00001B94  6700 FAF4               1238      BEQ         PRINT_OUT_BRA
00001B98  B67C 0001               1239      CMP         #%0001,D3
00001B9C  6700 FB1E               1240      BEQ         PRINT_OUT_BSR
00001BA0  6000 FB4C               1241      BRA         PRINT_OUT_Bcc
00001BA4  4E75                    1242      RTS
00001BA6  FFFF FFFF               1243      SIMHALT
00001BAA                          1244  
00001BAA                          1245  FIRST_NIBBLE_IS_7                                       * This is MOVEQ
00001BAA  3638 0200               1246      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001BAE  4EB8 19C4               1247      JSR         GET_THE_SECOND_NIBBLE
00001BB2  E14B                    1248      LSL         #8,D3
00001BB4  EF4B                    1249      LSL         #7,D3
00001BB6  E04B                    1250      LSR         #8,D3
00001BB8  EE4B                    1251      LSR         #7,D3
00001BBA  B67C 0000               1252      CMP         #0,D3
00001BBE  6700 F912               1253      BEQ         PRINT_OUT_MOVEQ
00001BC2  6000 F5D0               1254      BRA         INVALID
00001BC6  FFFF FFFF               1255      SIMHALT
00001BCA                          1256  
00001BCA                          1257  FIRST_NIBBLE_IS_8                                       * DIVS, Can't recognize SBCD
00001BCA  3638 0200               1258      MOVE.W      TEMP_CURRENT_4_NIBBLES, D3
00001BCE  4EB8 1A16               1259      JSR         CHECK_TYPE_DATA
00001BD2  0C78 0007 0300          1260      CMP         #%111, DESTINATION_MODE
00001BD8  6700 F808               1261      BEQ         PRINT_OUT_DIVS
00001BDC  0C78 0003 0300          1262      CMP         #%011, DESTINATION_MODE
00001BE2  6700 F5B0               1263      BEQ         INVALID                                 * This is DIVU
00001BE6  6000 F9B6               1264      BRA         PRINT_OUT_OR
00001BEA  4E75                    1265      RTS
00001BEC  FFFF FFFF               1266      SIMHALT
00001BF0                          1267  
00001BF0                          1268  FIRST_NIBBLE_IS_9                                       * SUB and SUBA           * No way of knowing SUX
00001BF0  3638 0200               1269      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001BF4  4EB8 1A16               1270      JSR         CHECK_TYPE_DATA
00001BF8  4EB8 19F4               1271      JSR         GET_NORMAL_SIZE
00001BFC  B67C 0003               1272      CMP         #%11,D3
00001C00  6700 F938               1273      BEQ         PRINT_OUT_SUBA                          * SUB Does not accept the size of 11
00001C04  6000 F9AC               1274      BRA         PRINT_OUT_SUB
00001C08  FFFF FFFF               1275      SIMHALT
00001C0C                          1276  
00001C0C                          1277  FIRST_NIBBLE_IS_A                                       * There are not any opcode with 1010
00001C0C  6000 F586               1278      BRA         INVALID
00001C10  FFFF FFFF               1279      SIMHALT
00001C14                          1280  
00001C14                          1281  FIRST_NIBBLE_IS_B                                       * CMP
00001C14  3638 0200               1282      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001C18  4EB8 1A16               1283      JSR         CHECK_TYPE_DATA
00001C1C  4EB8 19F4               1284      JSR         GET_NORMAL_SIZE
00001C20  B67C 0003               1285      CMP         #%11, D3
00001C24  6700 F56E               1286      BEQ         INVALID                                 * CMP does not accept size 11
00001C28  3638 0200               1287      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001C2C  4EB8 19C4               1288      JSR         GET_THE_SECOND_NIBBLE
00001C30  E14B                    1289      LSL         #8,D3                                   * Get the last bit of the second nibble
00001C32  EF4B                    1290      LSL         #7,D3
00001C34  EE4B                    1291      LSR         #7,D3
00001C36  E04B                    1292      LSR         #8,D3
00001C38  B67C 0000               1293      CMP         #0,D3                                   * CMP only accept 0 as the last bit in the second nibble
00001C3C  6600 F556               1294      BNE         INVALID
00001C40  6000 F844               1295      BRA         PRINT_OUT_CMP
00001C44  FFFF FFFF               1296      SIMHALT
00001C48                          1297  
00001C48                          1298  FIRST_NIBBLE_IS_C                                       * MULS and MULU
00001C48  3638 0200               1299      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001C4C  4EB8 1A16               1300      JSR         CHECK_TYPE_DATA
00001C50  4EB8 19F4               1301      JSR         GET_NORMAL_SIZE
00001C54  B67C 0003               1302      CMP         #%11,D3
00001C58  6600 F53A               1303      BNE         INVALID                                 * MULS only accept 11 as the size
00001C5C  3638 0200               1304      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001C60  4EB8 19C4               1305      JSR         GET_THE_SECOND_NIBBLE
00001C64  E14B                    1306      LSL         #8,D3                                   * Get the last bit of the second
00001C66  EF4B                    1307      LSL         #7,D3
00001C68  EE4B                    1308      LSR         #7,D3
00001C6A  E04B                    1309      LSR         #8,D3
00001C6C  B67C 0001               1310      CMP         #1,D3                                   * If it is 1, then it is MULS. Otherwise MULU
00001C70  6700 F7B4               1311      BEQ         PRINT_OUT_MULS
00001C74  6000 F808               1312      BRA         PRINT_OUT_MULU
00001C78  4E75                    1313      RTS
00001C7A  FFFF FFFF               1314      SIMHALT
00001C7E                          1315  
00001C7E                          1316  FIRST_NIBBLE_IS_D *ADD, ADDA                            * Have no way of knowing ADDX
00001C7E  3638 0200               1317      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001C82  4EB8 1A16               1318      JSR         CHECK_TYPE_DATA
00001C86  4EB8 19F4               1319      JSR         GET_NORMAL_SIZE
00001C8A  B67C 0003               1320      CMP         #%11,D3
00001C8E  6700 F8B4               1321      BEQ         PRINT_OUT_ADDA
00001C92  6000 F914               1322      BRA         PRINT_OUT_ADD
00001C96  4E75                    1323      RTS
00001C98  FFFF FFFF               1324      SIMHALT
00001C9C                          1325  
00001C9C                          1326  FIRST_NIBBLE_IS_E                                       * There are 2 types for every LSL,LSR,ASL,ASR,ROR,ROL. They can be seperated as LSd <ea> and other. They can be differentiate by the size 11
00001C9C  3638 0200               1327      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001CA0  4EB8 1A16               1328      JSR         CHECK_TYPE_DATA
00001CA4  4EB8 19F4               1329      JSR         GET_NORMAL_SIZE
00001CA8  B67C 0003               1330      CMP         #%11,D3
00001CAC  6700 002A               1331      BEQ         SPECIAL_SHIFT_INSTRUCTION               * Only the instructions with 11 in the size parts deal with <ea> (shift memory)
00001CB0  3638 0200               1332      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001CB4  4EB8 1A16               1333      JSR         CHECK_TYPE_DATA
00001CB8  4EB8 19CC               1334      JSR         GET_THE_THIRD_NIBBLE                    * For ASd and LSd, the lat bit is 0 of third nibble is 0
00001CBC  E14B                    1335          LSL         #8,D3                               * Get the last bit of the second
00001CBE  EF4B                    1336      LSL         #7,D3
00001CC0  EE4B                    1337      LSR         #7,D3
00001CC2  E04B                    1338      LSR         #8,D3
00001CC4  B67C 0000               1339      CMP         #0,D3
00001CC8  6700 FADE               1340      BEQ         PRINT_OUT_ASD_OR_LSD
00001CCC  6000 FB10               1341      BRA         PRINT_OUT_ROD                           * Could also be ROXD. If it is then invalid
00001CD0  4E75                    1342      RTS
00001CD2                          1343  
00001CD2                          1344  
00001CD2                          1345  FIRST_NIBBLE_IS_F * UNSUPPORTED
00001CD2  4E75                    1346      RTS
00001CD4  FFFF FFFF               1347      SIMHALT
00001CD8                          1348  
00001CD8                          1349  SPECIAL_SHIFT_INSTRUCTION                               *Asd, LSd,ROd with <ea>. Shift instructions
00001CD8  3638 0200               1350      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001CDC  4EB8 1A16               1351      JSR         CHECK_TYPE_DATA
00001CE0  4EB8 19C4               1352      JSR         GET_THE_SECOND_NIBBLE
00001CE4  E24B                    1353      LSR         #1, D3
00001CE6  B67C 0001               1354      CMP         #1,D3
00001CEA  6700 FA4C               1355      BEQ         PRINT_OUT_LOGICAL_SHIFT_MEM             * 001
00001CEE  B67C 0000               1356      CMP         #0,D3
00001CF2  6700 FA52               1357      BEQ         PRINT_OUT_ARITH_SHIFT_MEM               *000
00001CF6  B67C 0003               1358      CMP         #%11,D3
00001CFA  6700 FAA0               1359      BEQ         PRINT_OUT_ROTATE_MEM                    * 011
00001CFE  6000 F494               1360      BRA         INVALID                                 * Must be ROXd, UNSUPPORTED
00001D02  4E75                    1361      RTS
00001D04                          1362  
00001D04                          1363  *******************************************************************************
00001D04                          1364  * Jump table section
00001D04                          1365  *******************************************************************************
00001D04                          1366  * Used to figure out what type of mode and address where used to print
00001D04                          1367  REGISTER_MODE_JUMP_TABLE
00001D04  4EF9 00001D34           1368      JMP         REGISTER_MODE_000                       * Data register mode Dn
00001D0A  4EF9 00001D3E           1369      JMP         REGISTER_MODE_001                       * ADdress register mode   An
00001D10  4EF9 00001D48           1370      JMP         REGISTER_MODE_010                       * Indirect address register mode (An)
00001D16  4EF9 00001D56           1371      JMP         REGISTER_MODE_011                       *  Address register with increment (An)+
00001D1C  4EF9 00001D60           1372      JMP         REGISTER_MODE_100                       * Address register with decrement -(An)
00001D22  4EF9 00001D6A           1373      JMP         REGISTER_MODE_101                       * Not supported
00001D28  4EF9 00001D70           1374      JMP         REGISTER_MODE_110                       * Not supported
00001D2E  4EF9 00001D76           1375      JMP         REGISTER_MODE_111                       * This could be immediate, absolute short or absolute long
00001D34                          1376  
00001D34                          1377  REGISTER_MODE_000                                       * Print out data register Dn
00001D34  4EB8 195E               1378      JSR         PRINT_DATA_REGISTER
00001D38  4EB8 12F6               1379      JSR         PRINT_REGISTER_NUMBER
00001D3C  4E75                    1380      RTS
00001D3E                          1381  
00001D3E                          1382  REGISTER_MODE_001           * An
00001D3E  4EB8 1952               1383      JSR         PRINT_ADDRESS_REGISTER
00001D42  4EB8 12F6               1384      JSR         PRINT_REGISTER_NUMBER
00001D46  4E75                    1385      RTS
00001D48                          1386  
00001D48                          1387  REGISTER_MODE_010           * (An)
00001D48  4EB8 196A               1388      JSR         PRINT_OPEN_BRACKET
00001D4C  4EB8 1D3E               1389      JSR         REGISTER_MODE_001
00001D50  4EB8 1976               1390      JSR         PRINT_CLOSE_BRACKET
00001D54  4E75                    1391      RTS
00001D56                          1392  
00001D56                          1393  REGISTER_MODE_011           *(An)+
00001D56  4EB8 1D48               1394      JSR         REGISTER_MODE_010
00001D5A  4EB8 1982               1395      JSR         PRINT_PLUS_SIGN
00001D5E  4E75                    1396      RTS
00001D60                          1397  
00001D60                          1398  REGISTER_MODE_100       * -(An)
00001D60  4EB8 198E               1399      JSR         PRINT_MINUS_SIGN
00001D64  4EB8 1D48               1400      JSR         REGISTER_MODE_010
00001D68  4E75                    1401      RTS
00001D6A                          1402  
00001D6A                          1403  REGISTER_MODE_101                   * Not supported yet. Will deal later
00001D6A  6000 F428               1404      BRA         INVALID
00001D6E  4E75                    1405      RTS
00001D70                          1406  
00001D70                          1407  REGISTER_MODE_110                   * Not supported. Will deal later
00001D70  6000 F422               1408      BRA         INVALID
00001D74  4E75                    1409      RTS
00001D76                          1410  
00001D76                          1411  REGISTER_MODE_111                               * Immediate data, absolute long or absolute short
00001D76  49F9 00001DFA           1412      LEA         REGISTER_111_JUMP_TABLE,A4      * Print out the appropriate value
00001D7C  3638 0550               1413      MOVE.W      THIRD_TEMP_VAR,D3
00001D80  C6FC 0006               1414      MULU        #6,D3
00001D84  4EB4 3000               1415      JSR         0(A4,D3)
00001D88  49F9 00001D9C           1416      LEA         SHORT_OR_LONG_PRINT,A4          * Prepare the table to print out the data
00001D8E  3638 0550               1417      MOVE.W      THIRD_TEMP_VAR,D3
00001D92  C6FC 0006               1418      MULU        #6,D3                           * Use THIRD_TEMP_VAR as a place holder for the data we want to print out for register mode 111.
00001D96                          1419                                                  * In the code before this, we need to move the appropriate data into this address. Either the destination or the source
00001D96  4EB4 3000               1420      JSR         0(A4,D3)                        * Print out the appropriate long or short value
00001D9A  4E75                    1421      RTS
00001D9C                          1422  
00001D9C                          1423  * Third table that deal with printing out short .W or .L value
00001D9C                          1424  SHORT_OR_LONG_PRINT                             * Will jump to this when the register mode is 111 and not immediate data
00001D9C  4EF9 00001DBA           1425      JMP         ABSOLUTE_SHORT                  * Xn index for this is 000
00001DA2  4EF9 00001DC8           1426      JMP         ABSOLUTE_LONG                   * Xn index for this is 001
00001DA8  4EF9 00001DD6           1427      JMP         COUNTER_DISPLACEMENT
00001DAE  4EF9 00001DDE           1428      JMP         COUNTER_INDEX
00001DB4  4EF9 00001DE6           1429      JMP         IMMEDIATE_DATA
00001DBA                          1430  
00001DBA                          1431  ABSOLUTE_SHORT                                  *We need to get the next 4 bytes as the address to print out
00001DBA  4EB8 19DE               1432      JSR         GET_NEXT_FOUR_NIBBLE            * Got next 4 nibbles to print out as address
00001DBE  4EB8 1128               1433      JSR         CONVERT_HEX_TO_ASCII
00001DC2  4E75                    1434      RTS
00001DC4  FFFF FFFF               1435      SIMHALT
00001DC8                          1436  
00001DC8                          1437  ABSOLUTE_LONG                                   * Print the next 8 bytes as the address
00001DC8  4EB8 1DBA               1438      JSR         ABSOLUTE_SHORT                  * PRinted 4 bytes
00001DCC  4EB8 1DBA               1439      JSR         ABSOLUTE_SHORT                  * Printed 4 more
00001DD0  4E75                    1440      RTS
00001DD2  FFFF FFFF               1441      SIMHALT
00001DD6                          1442  
00001DD6                          1443  COUNTER_DISPLACEMENT                            * Not SUPPORTED
00001DD6  6000 F3BC               1444      BRA         INVALID
00001DDA  FFFF FFFF               1445      SIMHALT
00001DDE                          1446  
00001DDE                          1447  COUNTER_INDEX                                   * Not SUPPORTED
00001DDE  6000 F3B4               1448      BRA         INVALID
00001DE2  FFFF FFFF               1449      SIMHALT
00001DE6                          1450  
00001DE6                          1451      * Immediate data is also like absolute short and long. Will take advantage of that
00001DE6                          1452  IMMEDIATE_DATA
00001DE6  4EB8 19F4               1453      JSR         GET_NORMAL_SIZE                 * Now the first 2 bit of third nibble is on the right most
00001DEA  E24B                    1454      LSR         #1, D3                          * Byte aand word are mapped to absolute short => 00 and 01 after shift will go to 00
00001DEC                          1455                                                  * If the size is long, the it will go to absolute long 10 => 01
00001DEC  49F8 1D9C               1456      LEA         SHORT_OR_LONG_PRINT,A4          * Prepare the table to print out the data
00001DF0  C6FC 0006               1457      MULU        #6,D3                           * Use THIRD_TEMP_VAR as a place holder for the data we want to print out for register mode 111.
00001DF4                          1458                                                  * In the code before this, we need to move the appropriate data into this address. Either the destination or the source
00001DF4                          1459  
00001DF4  4EB4 3000               1460      JSR         0(A4,D3)                        * Print out the appropriate long or short value
00001DF8  4E75                    1461      RTS
00001DFA                          1462  
00001DFA                          1463  REGISTER_111_JUMP_TABLE
00001DFA  4EF9 00001E18           1464      JMP         PRINT_SHORT_SYMBOL
00001E00  4EF9 00001E1E           1465      JMP         PRINT_LONG_SYMBOL
00001E06  4EF9 00001E24           1466      JMP         PLACE_HOLDER_3 * Won't be reached
00001E0C  4EF9 00001E2C           1467      JMP         PLACE_HOLDER_4
00001E12  4EF9 00001E34           1468      JMP         PRINT_IMMEDIATE_DATA_AND_HEX
00001E18                          1469  
00001E18                          1470  PRINT_SHORT_SYMBOL
00001E18  4EB8 199A               1471      JSR         PRINT_HEX_SYMBOL
00001E1C  4E75                    1472      RTS
00001E1E                          1473  
00001E1E                          1474  PRINT_LONG_SYMBOL
00001E1E  4EB8 199A               1475      JSR         PRINT_HEX_SYMBOL
00001E22  4E75                    1476      RTS
00001E24                          1477  
00001E24                          1478  PLACE_HOLDER_3
00001E24  6000 F36E               1479      BRA         INVALID
00001E28  FFFF FFFF               1480      SIMHALT
00001E2C                          1481  
00001E2C                          1482  PLACE_HOLDER_4
00001E2C  6000 F366               1483      BRA        INVALID
00001E30  FFFF FFFF               1484      SIMHALT
00001E34                          1485  
00001E34                          1486  PRINT_IMMEDIATE_DATA_AND_HEX
00001E34  4EB8 19B2               1487      JSR         PRINT_IMMEDIATE_DATA_SYMBOL
00001E38  4EB8 199A               1488      JSR         PRINT_HEX_SYMBOL
00001E3C  4E75                    1489      RTS
00001E3E                          1490  
00001E3E                          1491  HEX_CHARACTER_JUMP_TABLE
00001E3E  4EF9 00001E9E           1492      JMP         PRINT_HEX_0
00001E44  4EF9 00001EAA           1493      JMP         PRINT_HEX_1
00001E4A  4EF9 00001EB6           1494      JMP         PRINT_HEX_2
00001E50  4EF9 00001EC2           1495      JMP         PRINT_HEX_3
00001E56  4EF9 00001ECE           1496      JMP         PRINT_HEX_4
00001E5C  4EF9 00001EDA           1497      JMP         PRINT_HEX_5
00001E62  4EF9 00001EE6           1498      JMP         PRINT_HEX_6
00001E68  4EF9 00001EF2           1499      JMP         PRINT_HEX_7
00001E6E  4EF9 00001EFE           1500      JMP         PRINT_HEX_8
00001E74  4EF9 00001F0A           1501      JMP         PRINT_HEX_9
00001E7A  4EF9 00001F16           1502      JMP         PRINT_HEX_A
00001E80  4EF9 00001F22           1503      JMP         PRINT_HEX_B
00001E86  4EF9 00001F2E           1504      JMP         PRINT_HEX_C
00001E8C  4EF9 00001F3A           1505      JMP         PRINT_HEX_D
00001E92  4EF9 00001F46           1506      JMP         PRINT_HEX_E
00001E98  4EF9 00001F52           1507      JMP         PRINT_HEX_F
00001E9E                          1508  
00001E9E                          1509  PRINT_HEX_0
00001E9E  43F9 00002306           1510      LEA         ZERO,A1
00001EA4  4EB8 18EA               1511      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001EA8  4E75                    1512      RTS
00001EAA                          1513  
00001EAA                          1514  PRINT_HEX_1
00001EAA  43F9 0000230A           1515      LEA         ONE,A1
00001EB0  4EB8 18EA               1516      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001EB4  4E75                    1517      RTS
00001EB6                          1518  
00001EB6                          1519  PRINT_HEX_2
00001EB6  43F9 0000230E           1520      LEA         TWO,A1
00001EBC  4EB8 18EA               1521      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001EC0  4E75                    1522      RTS
00001EC2                          1523  
00001EC2                          1524  PRINT_HEX_3
00001EC2  43F9 00002312           1525      LEA         THREE,A1
00001EC8  4EB8 18EA               1526      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001ECC  4E75                    1527      RTS
00001ECE                          1528  
00001ECE                          1529  PRINT_HEX_4
00001ECE  43F9 00002316           1530      LEA         FOUR,A1
00001ED4  4EB8 18EA               1531      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001ED8  4E75                    1532      RTS
00001EDA                          1533  
00001EDA                          1534  PRINT_HEX_5
00001EDA  43F9 0000231A           1535      LEA         FIVE,A1
00001EE0  4EB8 18EA               1536      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001EE4  4E75                    1537      RTS
00001EE6                          1538  
00001EE6                          1539  PRINT_HEX_6
00001EE6  43F9 0000231E           1540      LEA         SIX,A1
00001EEC  4EB8 18EA               1541      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001EF0  4E75                    1542      RTS
00001EF2                          1543  
00001EF2                          1544  PRINT_HEX_7
00001EF2  43F9 00002322           1545      LEA         SEVEN,A1
00001EF8  4EB8 18EA               1546      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001EFC  4E75                    1547      RTS
00001EFE                          1548  
00001EFE                          1549  PRINT_HEX_8
00001EFE  43F9 00002326           1550      LEA         EIGHT,A1
00001F04  4EB8 18EA               1551      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001F08  4E75                    1552      RTS
00001F0A                          1553  
00001F0A                          1554  PRINT_HEX_9
00001F0A  43F9 0000232A           1555      LEA         NINE,A1
00001F10  4EB8 18EA               1556      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001F14  4E75                    1557      RTS
00001F16                          1558  
00001F16                          1559  PRINT_HEX_A
00001F16  43F9 0000232E           1560      LEA         A,A1
00001F1C  4EB8 18EA               1561      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001F20  4E75                    1562      RTS
00001F22                          1563  
00001F22                          1564  PRINT_HEX_B
00001F22  43F9 00002332           1565      LEA         B,A1
00001F28  4EB8 18EA               1566      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001F2C  4E75                    1567      RTS
00001F2E                          1568  
00001F2E                          1569  PRINT_HEX_C
00001F2E  43F9 00002336           1570      LEA         C,A1
00001F34  4EB8 18EA               1571      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001F38  4E75                    1572      RTS
00001F3A                          1573  
00001F3A                          1574  PRINT_HEX_D
00001F3A  43F9 0000233A           1575      LEA         D,A1
00001F40  4EB8 18EA               1576      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001F44  4E75                    1577      RTS
00001F46                          1578  
00001F46                          1579  PRINT_HEX_E
00001F46  43F9 0000233E           1580      LEA         E,A1
00001F4C  4EB8 18EA               1581      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001F50  4E75                    1582      RTS
00001F52                          1583  
00001F52                          1584  PRINT_HEX_F
00001F52  43F9 00002342           1585      LEA         F,A1
00001F58  4EB8 18EA               1586      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001F5C  4E75                    1587      RTS
00001F5E                          1588  
00001F5E                          1589  MOVE_SIZE_PRINT_JUMP_TABLE
00001F5E  4EF9 00001F76           1590      JMP         UNSUPPORTED_MOVE_SIZE
00001F64  4EF9 00001F7C           1591      JMP         MOVE_BYTE_SUFFIX
00001F6A  4EF9 00001F8C           1592      JMP         MOVE_LONG_SUFFIX
00001F70  4EF9 00001F9C           1593      JMP         MOVE_WORD_SUFFIX
00001F76                          1594  
00001F76                          1595  UNSUPPORTED_MOVE_SIZE
00001F76  6000 F21C               1596      BRA         INVALID
00001F7A  4E75                    1597      RTS
00001F7C                          1598  
00001F7C                          1599  MOVE_BYTE_SUFFIX
00001F7C  43F9 000022FA           1600      LEA         BYTE_SUFFIX,A1
00001F82  4EB8 18EA               1601      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001F86  4EB8 19A6               1602      JSR         PRINT_EMPTY_SPACE
00001F8A  4E75                    1603      RTS
00001F8C                          1604  
00001F8C                          1605  MOVE_LONG_SUFFIX
00001F8C  43F9 00002302           1606      LEA         LONG_SUFFIX,A1
00001F92  4EB8 18EA               1607      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001F96  4EB8 19A6               1608      JSR         PRINT_EMPTY_SPACE
00001F9A  4E75                    1609      RTS
00001F9C                          1610  
00001F9C                          1611  MOVE_WORD_SUFFIX
00001F9C  43F9 000022FE           1612      LEA         WORD_SUFFIX,A1
00001FA2  4EB8 18EA               1613      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001FA6  4EB8 19A6               1614      JSR         PRINT_EMPTY_SPACE
00001FAA  4E75                    1615      RTS
00001FAC                          1616  
00001FAC                          1617  
00001FAC                          1618  NORMAL_SIZE_PRINT_JUMP_TABLE
00001FAC  4EF9 00001FC4           1619      JMP         PRINT_NORMAL_BYTE_SUFFIX
00001FB2  4EF9 00001FD4           1620      JMP         PRINT_NORMAL_WORD_SUFFIX
00001FB8  4EF9 00001FE4           1621      JMP         PRINT_NORMAL_LONG_SUFFIX
00001FBE  4EF9 00001FF4           1622      JMP         UNSUPPORTED_NORMAL_SUFFIX         * Could be move
00001FC4                          1623  
00001FC4                          1624  PRINT_NORMAL_BYTE_SUFFIX
00001FC4  43F9 000022FA           1625      LEA         BYTE_SUFFIX,A1
00001FCA  4EB8 18EA               1626      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001FCE  4EB8 19A6               1627      JSR         PRINT_EMPTY_SPACE
00001FD2  4E75                    1628      RTS
00001FD4                          1629  
00001FD4                          1630  PRINT_NORMAL_WORD_SUFFIX
00001FD4  43F9 000022FE           1631      LEA         WORD_SUFFIX,A1
00001FDA  4EB8 18EA               1632      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001FDE  4EB8 19A6               1633      JSR         PRINT_EMPTY_SPACE
00001FE2  4E75                    1634      RTS
00001FE4                          1635  
00001FE4                          1636  PRINT_NORMAL_LONG_SUFFIX
00001FE4  43F9 00002302           1637      LEA         LONG_SUFFIX,A1
00001FEA  4EB8 18EA               1638      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001FEE  4EB8 19A6               1639      JSR         PRINT_EMPTY_SPACE
00001FF2  4E75                    1640      RTS
00001FF4                          1641  
00001FF4                          1642  UNSUPPORTED_NORMAL_SUFFIX
00001FF4  6000 F19E               1643      BRA         INVALID
00001FF8  4E75                    1644      RTS
00001FFA                          1645  
00001FFA                          1646  *This jump table depends on the condition of Bcc
00001FFA                          1647  CONDITION_JUMP_TABLE
00001FFA  4EF9 0000205A           1648      JMP         CONDITION_TRUE
00002000  4EF9 0000205E           1649      JMP         CONDITION_FALSE
00002006  4EF9 00002062           1650      JMP         CONDITION_HIGHER
0000200C  4EF9 00002066           1651      JMP         CONDITION_LOWER_OR_SAME
00002012  4EF9 0000206A           1652      JMP         CONDITION_CARRY_CLEAR
00002018  4EF9 0000206E           1653      JMP         CONDITION_CARRY_SET                * Supported
0000201E  4EF9 0000207E           1654      JMP         CONDITION_NOT_EQUAL
00002024  4EF9 00002082           1655      JMP         CONDITION_EQUAL
0000202A  4EF9 00002086           1656      JMP         CONDITION_OVERFLOW_CLEAR            * Supported
00002030  4EF9 00002096           1657      JMP         CONDITION_OVERFLOW_SET
00002036  4EF9 0000209A           1658      JMP         CONDITION_PLUS
0000203C  4EF9 0000209E           1659      JMP         CONDITION_MINUS
00002042  4EF9 000020A2           1660      JMP         CONDITION_GREATER_OR_EQUAL         * Supported
00002048  4EF9 000020B2           1661      JMP         CONDITION_LESS_THAN                * SUPPORTED
0000204E  4EF9 000020C2           1662      JMP         CONDITION_GREATER_THAN
00002054  4EF9 000020C6           1663      JMP         CONDITION_LESS_OR_EQUAL
0000205A                          1664  
0000205A                          1665  CONDITION_TRUE
0000205A  6000 F138               1666      BRA         INVALID
0000205E                          1667  
0000205E                          1668  CONDITION_FALSE
0000205E  6000 F134               1669      BRA         INVALID
00002062                          1670  
00002062                          1671  CONDITION_HIGHER
00002062  6000 F130               1672      BRA         INVALID
00002066                          1673  
00002066                          1674  CONDITION_LOWER_OR_SAME
00002066  6000 F12C               1675      BRA         INVALID
0000206A                          1676  
0000206A                          1677  CONDITION_CARRY_CLEAR
0000206A  6000 F128               1678      BRA         INVALID
0000206E                          1679  
0000206E                          1680  
0000206E                          1681  
0000206E                          1682  CONDITION_CARRY_SET
0000206E  43F9 000022C0           1683      LEA         CARRY_SET_VALUE,A1
00002074  4EB8 18EA               1684      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00002078  4EB8 19A6               1685      JSR         PRINT_EMPTY_SPACE
0000207C  4E75                    1686      RTS
0000207E                          1687  
0000207E                          1688  CONDITION_NOT_EQUAL
0000207E  6000 F114               1689      BRA         INVALID
00002082                          1690  CONDITION_EQUAL
00002082  6000 F110               1691      BRA         INVALID
00002086                          1692  
00002086                          1693  CONDITION_OVERFLOW_CLEAR
00002086  43F9 000022B4           1694      LEA         OVERFLOW_CLEAR_VALUE,A1
0000208C  4EB8 18EA               1695      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00002090  4EB8 19A6               1696      JSR         PRINT_EMPTY_SPACE
00002094  4E75                    1697      RTS
00002096                          1698  
00002096                          1699  CONDITION_OVERFLOW_SET
00002096  6000 F0FC               1700      BRA         INVALID
0000209A                          1701  
0000209A                          1702  CONDITION_PLUS
0000209A  6000 F0F8               1703      BRA         INVALID
0000209E                          1704  
0000209E                          1705  CONDITION_MINUS
0000209E  6000 F0F4               1706      BRA         INVALID
000020A2                          1707  
000020A2                          1708  CONDITION_GREATER_OR_EQUAL
000020A2  43F9 000022B8           1709      LEA         GREATER_OR_EQUAL_VALUE,A1
000020A8  4EB8 18EA               1710      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
000020AC  4EB8 19A6               1711      JSR         PRINT_EMPTY_SPACE
000020B0  4E75                    1712      RTS
000020B2                          1713  
000020B2                          1714  CONDITION_LESS_THAN
000020B2  43F9 000022BC           1715      LEA         LESS_THAN_VALUE,A1
000020B8  4EB8 18EA               1716      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
000020BC  4EB8 19A6               1717      JSR         PRINT_EMPTY_SPACE
000020C0  4E75                    1718      RTS
000020C2                          1719  
000020C2                          1720  CONDITION_GREATER_THAN
000020C2  6000 F0D0               1721      BRA         INVALID
000020C6                          1722  
000020C6                          1723  CONDITION_LESS_OR_EQUAL
000020C6  6000 F0CC               1724      BRA         INVALID
000020CA                          1725  
000020CA                          1726  RIGHT_OR_LEFT_JUMP_TABLE
000020CA  4EF9 000020D6           1727      JMP         RIGHT_DIRECTION_PRINT
000020D0  4EF9 000020E2           1728      JMP         LEFT_DIRECTION_PRINT
000020D6                          1729  
000020D6                          1730  RIGHT_DIRECTION_PRINT
000020D6  43F9 00002290           1731      LEA         RIGHT_DIRECTION,A1
000020DC  4EB8 18EA               1732      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
000020E0  4E75                    1733      RTS
000020E2                          1734  
000020E2                          1735  LEFT_DIRECTION_PRINT
000020E2  43F9 0000228C           1736      LEA         LEFT_DIRECTION,A1
000020E8  4EB8 18EA               1737      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
000020EC  4E75                    1738      RTS
000020EE                          1739  
000020EE                          1740  IMMEDIATE_OR_REGISTER_JUMP_TABLE                * Use for ASd, LSd, ROd operations
000020EE  4EF9 000020FA           1741      JMP         IMMEDIATE_ROTATION
000020F4  4EF9 00002128           1742      JMP         REGISTER_ROTATION
000020FA                          1743  
000020FA                          1744  IMMEDIATE_ROTATION
000020FA  43F9 000022F6           1745      LEA         IMMEDIATE_DATA_SYMBOL,A1
00002100  4EB8 18EA               1746      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00002104  3638 0200               1747      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00002108  4EB8 19C4               1748      JSR         GET_THE_SECOND_NIBBLE
0000210C  E24B                    1749      LSR         #1,D3
0000210E  B67C 0000               1750      CMP         #0,D3
00002112  6700 003A               1751      BEQ         IMMEDIATE_ROTATION_HELPER       * For cases where the immediate is 0, make it 8
00002116  31C3 0550               1752      MOVE.W      D3, THIRD_TEMP_VAR              * Save the immediate data 1-8 we want to print
0000211A  4EB8 12F6               1753      JSR         PRINT_REGISTER_NUMBER
0000211E  4EB8 1946               1754      JSR         PRINT_COMMA
00002122  4EB8 19A6               1755      JSR         PRINT_EMPTY_SPACE
00002126  4E75                    1756      RTS
00002128                          1757  
00002128                          1758  REGISTER_ROTATION
00002128  43F9 000022DE           1759      LEA         DATA_REGISTER,A1
0000212E  4EB8 18EA               1760      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00002132  3638 0200               1761      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00002136  4EB8 19C4               1762      JSR         GET_THE_SECOND_NIBBLE
0000213A  E24B                    1763      LSR         #1,D3
0000213C  31C3 0550               1764      MOVE.W      D3,THIRD_TEMP_VAR
00002140  4EB8 12F6               1765      JSR         PRINT_REGISTER_NUMBER
00002144  4EB8 1946               1766      JSR         PRINT_COMMA
00002148  4EB8 19A6               1767      JSR         PRINT_EMPTY_SPACE
0000214C  4E75                    1768      RTS
0000214E                          1769  
0000214E                          1770  IMMEDIATE_ROTATION_HELPER
0000214E  31FC 0008 0550          1771      MOVE.W      #8,THIRD_TEMP_VAR
00002154  4EB8 12F6               1772      JSR         PRINT_REGISTER_NUMBER
00002158  4EB8 1946               1773      JSR         PRINT_COMMA
0000215C  4EB8 19A6               1774      JSR         PRINT_EMPTY_SPACE
00002160  4E75                    1775      RTS
00002162                          1776  
00002162                          1777  
00002162                          1778  
00002162                          1779  ******************************************************************
00002162                          1780  * Constant String that is used to print out the data is stored here
00002162                          1781  ******************************************************************
00002162= 506C 6561 7365 2...     1782  INTRO_STARTING          DC.W        'Please enter starting address',0
00002182= 506C 6561 7365 2...     1783  INTRO_ENDING            DC.W        'Please enter ending address',0
000021A0= 494E 5641 4C49 4...     1784  INVALID_INPUT           DC.W        'INVALID ADDRESS ENTERED',0
000021BA= 4669 6E69 7368 2...     1785  FINISH                  DC.W        'Finish Dissassembling. Starting address has reached or passed ending address',0
00002208= 4E4F 5000 0000          1786  NOP_VALUE               DC.W        'NOP',0     * Requested
0000220E= 5254 5300 0000          1787  RTS_VALUE               DC.W        'RTS',0     * Requested
00002214= 4F52 4900 0000          1788  ORI_VALUE               DC.W        'ORI',0     * Unfinished
0000221A= 4A53 5200 0000          1789  JSR_VALUE               DC.W        'JSR',0     * Requested
00002220= 4C45 4100 0000          1790  LEA_VALUE               DC.W        'LEA',0     * Requested
00002226= 4E45 4700 0000          1791  NEG_VALUE               DC.W        'NEG',0     * Requested
0000222C= 434D 5049 0000          1792  CMPI_VALUE              DC.W        'CMPI',0    * Requested
00002232= 434D 5000 0000          1793  CMP_VALUE               DC.W        'CMP',0     * Requested
00002238= 5355 4200 0000          1794  SUB_VALUE               DC.W        'SUB',0     * Requested
0000223E= 5355 4241 0000          1795  SUBA_VALUE              DC.W        'SUBA',0    * Extra
00002244= 5355 4251 0000          1796  SUBQ_VALUE              DC.W        'SUBQ',0    * Requested
0000224A= 4449 5653 0000          1797  DIVS_VALUE              DC.W        'DIVS',0    * Requested
00002250= 4252 4100 0000          1798  BRA_VALUE               DC.W        'BRA',0     * Requested
00002256= 4253 5200 0000          1799  BSR_VALUE               DC.W        'BSR',0     * Extra
0000225C= 4D55 4C53 0000          1800  MULS_VALUE              DC.W        'MULS',0    * Requested
00002262= 4D55 4C55 0000          1801  MULU_VALUE              DC.W        'MULU',0    * Extra
00002268= 4144 4400 0000          1802  ADD_VALUE               DC.W        'ADD',0     * Requested
0000226E= 4144 4441 0000          1803  ADDA_VALUE              DC.W        'ADDA',0    * Requested
00002274= 4144 4451 0000          1804  ADDQ_VALUE              DC.W        'ADDQ',0    * Extra
0000227A= 4153 0000               1805  AS_VALUE                DC.W        'AS',0      * Requested ASR, ASL
0000227E= 4C53 0000               1806  LS_VALUE                DC.W        'LS',0      * Requested LSR, LSL
00002282= 524F 0000               1807  RO_VALUE                DC.W        'RO',0      * Requested ROR, ROL
00002286= 4243 4C52 0000          1808  BCLR_VALUE              DC.W        'BCLR',0    * Unfinished
0000228C= 4C00 0000               1809  LEFT_DIRECTION          DC.W        'L',0
00002290= 5200 0000               1810  RIGHT_DIRECTION         DC.W        'R',0
00002294= 4F52 0000               1811  OR_VALUE                DC.W        'OR',0      * Extra
00002298= 4D4F 5645 4100 0000     1812  MOVEA_VALUE             DC.W        'MOVEA',0   * Requested
000022A0= 4D4F 5645 0000          1813  MOVE_VALUE              DC.W        'MOVE',0    * Requested
000022A6= 4D4F 5645 5100 0000     1814  MOVEQ_VALUE             DC.W        'MOVEQ',0   * Extra
000022AE= 4441 5441 0000          1815  DATA_VALUE              DC.W        'DATA',0
000022B4= 5643 0000               1816  OVERFLOW_CLEAR_VALUE    DC.W        'VC',0
000022B8= 4745 0000               1817  GREATER_OR_EQUAL_VALUE  DC.W        'GE',0
000022BC= 4C54 0000               1818  LESS_THAN_VALUE         DC.W        'LT',0
000022C0= 4353 0000               1819  CARRY_SET_VALUE         DC.W        'CS',0
000022C4= 5352 0000               1820  SR_VALUE                DC.W        'SR',0
000022C8= 4343 5200 0000          1821  CCR_VALUE               DC.W        'CCR',0
000022CE= 2800 0000               1822  OPENING_BRACKET         DC.W        '(',0
000022D2= 2900 0000               1823  CLOSING_BRACKET         DC.W        ')',0
000022D6= 2B00 0000               1824  PLUS_SIGN               DC.W        '+',0
000022DA= 2D00 0000               1825  MINUS_SIGN              DC.W        '-',0
000022DE= 4400 0000               1826  DATA_REGISTER           DC.W        'D',0
000022E2= 4100 0000               1827  ADDRESS_REGISTER        DC.W        'A',0
000022E6= 2C00 0000               1828  COMMA                   DC.W        ',',0
000022EA= 2000 0000               1829  SPACE                   DC.W        ' ',0
000022EE= 2500 0000               1830  BINARY_SYMBOL           DC.W        '%',0
000022F2= 2400 0000               1831  HEX_SYMBOL              DC.W        '$',0
000022F6= 2300 0000               1832  IMMEDIATE_DATA_SYMBOL   DC.W        '#',0
000022FA= 2E42 0000               1833  BYTE_SUFFIX             DC.W        '.B',0
000022FE= 2E57 0000               1834  WORD_SUFFIX             DC.W        '.W',0
00002302= 2E4C 0000               1835  LONG_SUFFIX             DC.W        '.L',0
00002306= 3000 0000               1836  ZERO                    DC.W        '0',0
0000230A= 3100 0000               1837  ONE                     DC.W        '1',0
0000230E= 3200 0000               1838  TWO                     DC.W        '2',0
00002312= 3300 0000               1839  THREE                   DC.W        '3',0
00002316= 3400 0000               1840  FOUR                    DC.W        '4',0
0000231A= 3500 0000               1841  FIVE                    DC.W        '5',0
0000231E= 3600 0000               1842  SIX                     DC.W        '6',0
00002322= 3700 0000               1843  SEVEN                   DC.W        '7',0
00002326= 3800 0000               1844  EIGHT                   DC.W        '8',0
0000232A= 3900 0000               1845  NINE                    DC.W        '9',0
0000232E= 4100 0000               1846  A                       DC.W        'A',0
00002332= 4200 0000               1847  B                       DC.W        'B',0
00002336= 4300 0000               1848  C                       DC.W        'C',0
0000233A= 4400 0000               1849  D                       DC.W        'D',0
0000233E= 4500 0000               1850  E                       DC.W        'E',0
00002342= 4600 0000               1851  F                       DC.W        'F',0
00002346                          1852  
00002346                          1853  
00002346                          1854      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
A                   232E
ABSOLUTE_LONG       1DC8
ABSOLUTE_SHORT      1DBA
ADDA_VALUE          226E
ADDQ_AND_SUBQ_HELPER  136C
ADDQ_VALUE          2274
ADDRESS_REGISTER    22E2
ADD_AND_SUB_HELPER  15BC
ADD_VALUE           2268
ASD_LSD_ROD_HELPER_FUNCTION  1800
ASD_LSD_ROD_SHIFT_HELPER  1754
AS_VALUE            227A
B                   2332
BCLR_VALUE          2286
BINARY_SYMBOL       22EE
BRA_VALUE           2250
BSR_VALUE           2256
BYTE_SUFFIX         22FA
C                   2336
CARRY_SET_VALUE     22C0
CCR_VALUE           22C8
CHECK_TYPE_DATA     1A16
CLOSING_BRACKET     22D2
CMPI_VALUE          222C
CMP_VALUE           2232
COMMA               22E6
CONDITION_CARRY_CLEAR  206A
CONDITION_CARRY_SET  206E
CONDITION_EQUAL     2082
CONDITION_FALSE     205E
CONDITION_GREATER_OR_EQUAL  20A2
CONDITION_GREATER_THAN  20C2
CONDITION_HIGHER    2062
CONDITION_JUMP_TABLE  1FFA
CONDITION_LESS_OR_EQUAL  20C6
CONDITION_LESS_THAN  20B2
CONDITION_LOWER_OR_SAME  2066
CONDITION_MINUS     209E
CONDITION_NOT_EQUAL  207E
CONDITION_OVERFLOW_CLEAR  2086
CONDITION_OVERFLOW_SET  2096
CONDITION_PLUS      209A
CONDITION_TRUE      205A
CONVERT_ASCII_TO_HEX  1060
CONVERT_CHARACTER_ASCII_TO_HEX  1086
CONVERT_HEX_TO_ASCII  1128
COUNTER_DISPLACEMENT  1DD6
COUNTER_INDEX       1DDE
D                   233A
DATA_REGISTER       22DE
DATA_VALUE          22AE
DESTINATION_MODE    300
DESTINATION_VAR     250
DIVS_VALUE          224A
E                   233E
EIGHT               2326
ENDING_ADDRESS      150
ERROR_INVALID_INPUT  1120
F                   2342
FIFTH_TEMP_VAR      650
FINISH              21BA
FINISH_CONVERT_ENDING_ADDRESS  10C4
FINISH_CONVERT_STARTING_ADDRESS  10AA
FINISH_DISASSEMBLING  1A08
FIRST_NIBBLE_4_SECOND_NIBBLE_E  1A5C
FIRST_NIBBLE_IS_0   1AF4
FIRST_NIBBLE_IS_1   1B0A
FIRST_NIBBLE_IS_2   1B12
FIRST_NIBBLE_IS_3   1B1A
FIRST_NIBBLE_IS_4   1B22
FIRST_NIBBLE_IS_5   1B52
FIRST_NIBBLE_IS_6   1B88
FIRST_NIBBLE_IS_7   1BAA
FIRST_NIBBLE_IS_8   1BCA
FIRST_NIBBLE_IS_9   1BF0
FIRST_NIBBLE_IS_A   1C0C
FIRST_NIBBLE_IS_B   1C14
FIRST_NIBBLE_IS_C   1C48
FIRST_NIBBLE_IS_D   1C7E
FIRST_NIBBLE_IS_E   1C9C
FIRST_NIBBLE_IS_F   1CD2
FIRST_NIBBLE_JUMP_TABLE  1A94
FIVE                231A
FOUR                2316
FOURTH_TEMP_VAR     600
GET_END_ADDRESS     1024
GET_NEXT_FOUR_NIBBLE  19DE
GET_NEXT_TWO_NIBBLE  19EC
GET_NORMAL_SIZE     19F4
GET_START_ADDRESS   1000
GET_THE_FIRST_NIBBLE  19BE
GET_THE_FOURTH_NIBBLE  19D4
GET_THE_SECOND_NIBBLE  19C4
GET_THE_THIRD_NIBBLE  19CC
GREATER_OR_EQUAL_VALUE  22B8
HEX_CHARACTER_JUMP_TABLE  1E3E
HEX_SYMBOL          22F2
IMMEDIATE_DATA      1DE6
IMMEDIATE_DATA_SYMBOL  22F6
IMMEDIATE_OR_REGISTER_JUMP_TABLE  20EE
IMMEDIATE_ROTATION  20FA
IMMEDIATE_ROTATION_HELPER  214E
INTRO_ENDING        2182
INTRO_STARTING      2162
INVALID             1194
INVALID_ENDING_ADDRESS  1108
INVALID_INPUT       21A0
INVALID_STARTING_ADDRESS  10F0
JSR_VALUE           221A
LEA_VALUE           2220
LEFT_DIRECTION      228C
LEFT_DIRECTION_PRINT  20E2
LESS_THAN_VALUE     22BC
LONG_SUFFIX         2302
LS_VALUE            227E
MINUS_SIGN          22DA
MOVEA_VALUE         2298
MOVEQ_VALUE         22A6
MOVE_BYTE_SUFFIX    1F7C
MOVE_LONG_SUFFIX    1F8C
MOVE_OPCODE_HELPER  1878
MOVE_SECOND_OPCODE_HELPER  18AA
MOVE_SIZE_PRINT_JUMP_TABLE  1F5E
MOVE_VALUE          22A0
MOVE_WORD_SUFFIX    1F9C
MULS_AND_MULU_HELPER  1430
MULS_VALUE          225C
MULU_VALUE          2262
NEG_VALUE           2226
NINE                232A
NOP_VALUE           2208
NORMAL_SIZE_PRINT_JUMP_TABLE  1FAC
ONE                 230A
OPENING_BRACKET     22CE
ORI_VALUE           2214
OR_VALUE            2294
OVERFLOW_CLEAR_VALUE  22B4
PARSING_OP_CODE     103E
PLACE_HOLDER_3      1E24
PLACE_HOLDER_4      1E2C
PLUS_SIGN           22D6
PREPARE_START_AND_END_ADDRESS  117A
PRINT_ADDRESS_LOCATION  1926
PRINT_ADDRESS_REGISTER  1952
PRINT_CLOSE_BRACKET  1976
PRINT_COMMA         1946
PRINT_DATA_MODE_DESTINATION  190C
PRINT_DATA_MODE_SOURCE  18F2
PRINT_DATA_REGISTER  195E
PRINT_EMPTY_SPACE   19A6
PRINT_HEX_0         1E9E
PRINT_HEX_1         1EAA
PRINT_HEX_2         1EB6
PRINT_HEX_3         1EC2
PRINT_HEX_4         1ECE
PRINT_HEX_5         1EDA
PRINT_HEX_6         1EE6
PRINT_HEX_7         1EF2
PRINT_HEX_8         1EFE
PRINT_HEX_9         1F0A
PRINT_HEX_A         1F16
PRINT_HEX_B         1F22
PRINT_HEX_C         1F2E
PRINT_HEX_D         1F3A
PRINT_HEX_E         1F46
PRINT_HEX_F         1F52
PRINT_HEX_SYMBOL    199A
PRINT_IMMEDIATE_DATA_AND_HEX  1E34
PRINT_IMMEDIATE_DATA_SYMBOL  19B2
PRINT_LONG_SYMBOL   1E1E
PRINT_MINUS_SIGN    198E
PRINT_NORMAL_BYTE_SUFFIX  1FC4
PRINT_NORMAL_LONG_SUFFIX  1FE4
PRINT_NORMAL_SUFFIX  12D4
PRINT_NORMAL_WORD_SUFFIX  1FD4
PRINT_NOT_NORMAL_SUFFIX  12C2
PRINT_OPEN_BRACKET  196A
PRINT_OUT_ADD       15A8
PRINT_OUT_ADDA      1544
PRINT_OUT_ADDQ      1358
PRINT_OUT_ARITH_SHIFT_MEM  1746
PRINT_OUT_ASD       17C2
PRINT_OUT_ASD_OR_LSD  17A8
PRINT_OUT_BCC       16EE
PRINT_OUT_BRA       168A
PRINT_OUT_BSR       16BC
PRINT_OUT_CMP       1486
PRINT_OUT_CMPI      1266
PRINT_OUT_DIVS      13E2
PRINT_OUT_JSR       123C
PRINT_OUT_LEA       1310
PRINT_OUT_LOGICAL_SHIFT_MEM  1738
PRINT_OUT_LSD       17D0
PRINT_OUT_MOVE      189E
PRINT_OUT_MOVEA     1892
PRINT_OUT_MOVEQ     14D2
PRINT_OUT_MULS      1426
PRINT_OUT_MULU      147E
PRINT_OUT_NEG       11C2
PRINT_OUT_NOP       11FC
PRINT_OUT_OR        159E
PRINT_OUT_ORI_TO_SR  1226
PRINT_OUT_ROD       17DE
PRINT_OUT_ROTATE_MEM  179C
PRINT_OUT_RTS       1210
PRINT_OUT_SUB       15B2
PRINT_OUT_SUBA      153A
PRINT_OUT_SUBQ      1362
PRINT_PLUS_SIGN     1982
PRINT_REGISTER_NUMBER  12F6
PRINT_SHORT_SYMBOL  1E18
PRINT_TO_SCREEN_ENTIRE_STRING  18EA
REGISTER_111_JUMP_TABLE  1DFA
REGISTER_MODE_000   1D34
REGISTER_MODE_001   1D3E
REGISTER_MODE_010   1D48
REGISTER_MODE_011   1D56
REGISTER_MODE_100   1D60
REGISTER_MODE_101   1D6A
REGISTER_MODE_110   1D70
REGISTER_MODE_111   1D76
REGISTER_MODE_JUMP_TABLE  1D04
REGISTER_ROTATION   2128
RIGHT_DIRECTION     2290
RIGHT_DIRECTION_PRINT  20D6
RIGHT_OR_LEFT_JUMP_TABLE  20CA
RO_VALUE            2282
RTS_VALUE           220E
SEVEN               2322
SHORT_OR_LONG_PRINT  1D9C
SIX                 231E
SOURCE_MODE         350
SOURCE_VAR          400
SPACE               22EA
SPECIAL_SHIFT_INSTRUCTION  1CD8
SR_VALUE            22C4
START               1000
STARTING_ADDRESS    100
SUBA_AND_ADDA_HELPER  154E
SUBA_VALUE          223E
SUBQ_HELPER_FUNCTION  13BC
SUBQ_VALUE          2244
SUB_HELPER_FUNCTION  160C
SUB_HELPER_REGISTER_TO_MEM  1668
SUB_VALUE           2238
TEMP_CURRENT_2_NIBBLES  750
TEMP_CURRENT_4_NIBBLES  200
THIRD_TEMP_VAR      550
THREE               2312
TWO                 230E
UNSUPPORTED_MOVE_SIZE  1F76
UNSUPPORTED_NORMAL_SUFFIX  1FF4
USER_INPUT_ENTER    118C
WORD_SUFFIX         22FE
ZERO                2306
