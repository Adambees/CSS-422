00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 2/26/2018 2:41:02 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : First simple implementation of printing out NOP
00000000                             3  * Written by : Thuan Tran
00000000                             4  * Date       : Feb 25th,2018
00000000                             5  * Description: Load the test program in prototype, testNop. Enter starting and ending address. Expected to print out NOP
00000000                             6  *-----------------------------------------------------------
00000000                             7  
00000000                             8  *** A2 will be used as the address in which it will iterate through all the way until ending adrress
00000000                             9  
00000000  =00000100                 10  STARTING_ADDRESS   EQU    $100 * User input starting address
00000000  =00000200                 11  ENDING_ADDRESS     EQU    $200 * User input ending address
00000000  =00000300                 12  TEMP_VAR           EQU    $300 * Temporary variables to start decode
00000000                            13  
00000000  =00000400                 14  DESTINATION_VAR    EQU    $400
00000000  =00000500                 15  DESTINATION_MODE   EQU    $500
00000000  =00000600                 16  SOURCE_MODE        EQU    $600
00000000  =00000700                 17  SOURCE_VAR         EQU    $700
00000000                            18  
00001000                            19      ORG    $1000
00001000                            20  START:                  ; first instruction of program
00001000                            21  
00001000                            22  GET_START_ADDRESS
00001000  43F9 000012D6             23      LEA INTRO_STARTING,A1  * Welcome the user
00001006  103C 000D                 24      MOVE.B  #13,D0         * Nice to have carry and line feed
0000100A  4E4F                      25      TRAP    #15
0000100C  103C 0002                 26      MOVE.B  #2,D0          * Get a string input that represent the user
00001010  4E4F                      27      TRAP    #15
00001012  6000 00CE                 28      BRA     CONVERT_ASCII_TO_HEX
00001016                            29  
00001016                            30  GET_END_ADDRESS
00001016  43F9 00001312             31      LEA INTRO_ENDING,A1         * Now time to get the ending address
0000101C  103C 000D                 32      MOVE.B  #13,D0
00001020  4E4F                      33      TRAP    #15
00001022  103C 0002                 34      MOVE.B  #2,D0
00001026  4E4F                      35      TRAP    #15
00001028  6000 00B8                 36      BRA     CONVERT_ASCII_TO_HEX
0000102C                            37  
0000102C                            38  PARSING_OP_CODE * Decode the first four byte. Will go throug each 2 bytes at a time
0000102C  3612                      39      MOVE.W      (A2),D3 * Get the first 4 bytes of op code
0000102E  31C3 0300                 40      MOVE.W      D3, TEMP_VAR
00001032  E04B                      41      LSR       #8,D3            * Get the left most byte. 0000XYBC now will get 0000000X
00001034  E84B                      42      LSR       #4,D3              * Now shift remaing 4 bit. LSR only allow 1-8 bit shift
00001036  C6FC 0006                 43      MULU      #6,D3
0000103A  4EB0 3000                 44      JSR        0(A0,D3)
0000103E                            45  
0000103E  FFFF FFFF                 46      SIMHALT
00001042                            47  
00001042                            48  
00001042                            49  PREPARE_START_AND_END_ADDRESS * When finish getting the ending adress, will load data into address regist
00001042  41F9 00001052             50      LEA         FIRST_BYTE_JUMP_TABLE,A0
00001048  2478 0100                 51      MOVE.L      STARTING_ADDRESS,A2
0000104C  2678 0200                 52      MOVE.L      ENDING_ADDRESS,A3
00001050  60DA                      53      BRA         PARSING_OP_CODE * Start parsing the opcode now
00001052                            54  
00001052                            55  FIRST_BYTE_JUMP_TABLE
00001052  4EF9 00001158             56      JMP  FIRST_BYTE_IS_0
00001058  4EF9 00001164             57      JMP  FIRST_BYTE_IS_1
0000105E  4EF9 0000116A             58      JMP  FIRST_BYTE_IS_2
00001064  4EF9 00001170             59      JMP  FIRST_BYTE_IS_3
0000106A  4EF9 00001176             60      JMP  FIRST_BYTE_IS_4
00001070  4EF9 0000121A             61      JMP  FIRST_BYTE_IS_5
00001076  4EF9 00001220             62      JMP  FIRST_BYTE_IS_6
0000107C  4EF9 00001226             63      JMP  FIRST_BYTE_IS_7
00001082  4EF9 0000122C             64      JMP  FIRST_BYTE_IS_8
00001088  4EF9 00001232             65      JMP  FIRST_BYTE_IS_9
0000108E  4EF9 00001238             66      JMP  FIRST_BYTE_IS_A
00001094  4EF9 0000123E             67      JMP  FIRST_BYTE_IS_B
0000109A  4EF9 00001244             68      JMP  FIRST_BYTE_IS_C
000010A0  4EF9 0000124A             69      JMP  FIRST_BYTE_IS_D
000010A6  4EF9 00001250             70      JMP  FIRST_BYTE_IS_E
000010AC  4EF9 00001256             71      JMP  FIRST_BYTE_IS_F
000010B2                            72  
000010B2                            73  REGISTER_MODE_JUMP_TABLE
000010B2  4EF9 000012D6             74      JMP REGISTER_MODE_000             * Data register mode
000010B8  4EF9 000012D6             75      JMP REGISTER_MODE_001             * ADdress register mode
000010BE  4EF9 000012D6             76      JMP REGISTER_MODE_010
000010C4  4EF9 000012D6             77      JMP REGISTER_MODE_011
000010CA  4EF9 000012D6             78      JMP REGISTER_MODE_100
000010D0  4EF9 000012D6             79      JMP REGISTER_MODE_101
000010D6  4EF9 000012D6             80      JMP REGISTER_MODE_110
000010DC  4EF9 000012D6             81      JMP REGISTER_MODE_111
000010E2                            82  
000010E2                            83  
000010E2                            84  
000010E2                            85  
000010E2                            86  
000010E2                            87  
000010E2                            88  
000010E2                            89  
000010E2                            90  
000010E2                            91  CONVERT_ASCII_TO_HEX            * ascii table http://www.asciitable.com/
000010E2  1019                      92      MOVE.B (A1)+,D0       * Go through each byte of the address
000010E4  B03C 0030                 93      CMP.B   #$30,D0       * Valid data are from $30 - $39 ( 0-9) and $41 - $46 (A-F)
000010E8  6D1A                      94      BLT.B   ERROR_INVALID_INPUT
000010EA  B03C 0039                 95      CMP.B   #$39,D0          * check if in the range number of hex character
000010EE  6E24                      96      BGT.B   CONVERT_CHARACTER_ASCII_TO_HEX
000010F0  0400 0030                 97      SUB.B   #$30,D0     * Get the hex range from '0-9'
000010F4  D680                      98      ADD.L   D0,D3
000010F6  5341                      99      SUBI    #1,D1          * Decrement the counter for length of address
000010F8  B23C 0000                100      CMP.B   #0,D1
000010FC  6700 0036                101      BEQ     FINISH_CONVERT_STARTING_ADDRESS
00001100  E98B                     102      LSL.L   #4,D3
00001102  60DE                     103      BRA     CONVERT_ASCII_TO_HEX
00001104                           104  
00001104                           105  ERROR_INVALID_INPUT
00001104  43F9 00001330            106      LEA INVALID_INPUT,A1   * Print out to the user invalid message and stop the program
0000110A  103C 000D                107      MOVE.B  #13,D0
0000110E  4E4F                     108      TRAP    #15
00001110  FFFF FFFF                109      SIMHALT
00001114                           110  
00001114                           111  CONVERT_CHARACTER_ASCII_TO_HEX
00001114  B03C 0041                112      CMP.B   #$41,D0                        * At this point, the data must be larger than number
00001118  6DEA                     113      BLT.B   ERROR_INVALID_INPUT            * Only $41 - 46 are valid
0000111A  B03C 0046                114      CMP.B   #$46,D0
0000111E  6EE4                     115      BGT.B   ERROR_INVALID_INPUT             * Greater than $46, nope
00001120  0400 0037                116      SUB.B   #$37,D0                         * Get the A-F value
00001124  D680                     117      ADD.L   D0,D3                           * Save the value
00001126  5341                     118      SUBI    #1,D1                           * Decrement the counter
00001128  B23C 0000                119      CMP.B   #0,D1
0000112C  6700 0006                120      BEQ     FINISH_CONVERT_STARTING_ADDRESS
00001130  E98B                     121      LSL.L   #4,D3                           * Shift the value to the left 4 bits to save room for another byte
00001132  60AE                     122      BRA     CONVERT_ASCII_TO_HEX
00001134                           123  
00001134                           124  FINISH_CONVERT_STARTING_ADDRESS
00001134  B47C 0001                125      CMP     #1,D2                      * Check if we are doing starting or ending address
00001138  6700 000E                126      BEQ     FINISH_CONVERT_ENDING_ADDRESS
0000113C  5242                     127      ADDI    #1,D2 * Counter to make sure that we are doing the ending address
0000113E  21C3 0100                128      MOVE.L  D3,STARTING_ADDRESS
00001142  4283                     129      CLR.L   D3
00001144  6000 FED0                130      BRA     GET_END_ADDRESS
00001148                           131  
00001148                           132  FINISH_CONVERT_ENDING_ADDRESS
00001148  4242                     133      CLR.W   D2       * Clear the second data register for future use
0000114A  21C3 0200                134      MOVE.L  D3,ENDING_ADDRESS
0000114E  4243                     135      CLR.W   D3
00001150  6000 FEF0                136      BRA     PREPARE_START_AND_END_ADDRESS
00001154  FFFF FFFF                137      SIMHALT
00001158                           138  
00001158                           139  FIRST_BYTE_IS_0
00001158  1638 0300                140      MOVE.B  TEMP_VAR,D3
0000115C  B63C 0000                141      CMP.B   #$00,D3
00001160  6700 0112                142      BEQ     SECOND_BYTE_IS_0
00001164                           143  
00001164                           144  
00001164                           145  
00001164                           146  
00001164                           147  FIRST_BYTE_IS_1
00001164  4E75                     148      RTS
00001166  FFFF FFFF                149      SIMHALT
0000116A                           150  FIRST_BYTE_IS_2
0000116A  4E75                     151      RTS
0000116C  FFFF FFFF                152      SIMHALT
00001170                           153  FIRST_BYTE_IS_3
00001170  4E75                     154      RTS
00001172  FFFF FFFF                155      SIMHALT
00001176                           156  FIRST_BYTE_IS_4                 * Possible for NOP,LEA,RTS,JSR,NEG. Now will check the second byte
00001176  3638 0300                157      MOVE.W  TEMP_VAR,D3         * Get the original op code back
0000117A  E94B                     158      LSL     #4,D3               * Go to the left 4 bits, make the second byte the left most byte    0000 1234 => 0000 2340
0000117C  E04B                     159      LSR     #8,D3               * Go back 2 bytes, now on the third most byte 0000 2340 => 0000 0023
0000117E  E84B                     160      LSR     #4,D3               * Go back 1 bytes, now on the fourth byte    0000 0023 => 0002
00001180  B63C 000E                161      CMP.B   #$E,D3
00001184  6700 00D6                162      BEQ     FIRST_BYTE_4_SECOND_BYTE_E
00001188  B63C 0008                163      CMP.B   #8,D3              * Could be NEG or LEA
0000118C  6D00 0002                164      BLT     NEG_OR_LEA
00001190                           165  
00001190                           166  INVALID
00001190                           167  
00001190                           168  NEG_OR_LEA                     * Check the 8-6 bits of NEG and LEA. For NEG, the 8-6 bits are 0S where S is the size. For LEA, it is 111
00001190  3638 0300                169      MOVE.W  TEMP_VAR,D3
00001194  EF4B                     170      LSL     #7,D3              * Get rid of 7 left most bit
00001196  EE4B                     171      LSR     #7,D3              * Return back to the original position
00001198  EC4B                     172      LSR     #6,D3              * Push them back all the way to the right
0000119A  B63C 0007                173      CMP.B   #$07,D3
0000119E  6700 0046                174      BEQ     PRINT_LEA          * This is LEA
000011A2                           175  
000011A2  60EC                     176      BRA     INVALID            * Unrecognized instructions
000011A4                           177  
000011A4                           178  
000011A4                           179  
000011A4                           180  
000011A4                           181  
000011A4                           182  CHECK_TYPE_DATA
000011A4  3638 0300                183      MOVE.W TEMP_VAR,D3
000011A8  E94B                     184      LSL     #4,D3      * Get rid of left most byte
000011AA  E84B                     185      LSR     #4,D3      * Now focus on the following format      destination mode mode source. Start with destination first
000011AC  E04B                     186      LSR     #8,D3      * Now the D3 has the destination
000011AE  E24B                     187      LSR     #1,D3
000011B0  31C3 0400                188      MOVE.W  D3,DESTINATION_VAR
000011B4  3638 0300                189      MOVE.W  TEMP_VAR,D3 * Now go with the destination mode
000011B8  EF4B                     190      LSL     #7,D3
000011BA  EE4B                     191      LSR     #7,D3
000011BC  EC4B                     192      LSR     #6,D3
000011BE  31C3 0500                193      MOVE.W  D3,DESTINATION_MODE
000011C2  3638 0300                194      MOVE.W  TEMP_VAR,D3       * Now extract the source mode
000011C6  E14B                     195      LSL     #8,D3
000011C8  E54B                     196      LSL     #2,D3
000011CA  E04B                     197      LSR     #8,D3
000011CC  E44B                     198      LSR     #2,D3
000011CE  E64B                     199      LSR     #3,D3
000011D0  31C3 0600                200      MOVE.W  D3,SOURCE_MODE      * Now extract the source
000011D4  3638 0300                201      MOVE.W  TEMP_VAR,D3
000011D8  E14B                     202      LSL     #8,D3
000011DA  EB4B                     203      LSL     #5,D3
000011DC  E04B                     204      LSR     #8,D3
000011DE  EA4B                     205      LSR     #5,D3
000011E0  31C3 0700                206      MOVE.W  D3,SOURCE_VAR
000011E4  4E75                     207      RTS
000011E6                           208  
000011E6                           209  
000011E6                           210  
000011E6                           211  
000011E6                           212  
000011E6                           213  
000011E6                           214  
000011E6                           215  
000011E6                           216  
000011E6                           217  PRINT_LEA
000011E6  4EB8 11A4                218      JSR CHECK_TYPE_DATA * Check what type of data we are dealing with and whether we need to out more to fetch data
000011EA                           219  
000011EA  0C78 0000 0600           220      CMP #$0,SOURCE_MODE
000011F0  4EB9 000011FC            221      JSR PRINT_DATA_MODE
000011F6  4EB9 0000120C            222      JSR PRINT_COMMA
000011FC                           223  
000011FC                           224  
000011FC                           225  
000011FC                           226  PRINT_DATA_MODE
000011FC  47F8 10B2                227      LEA     REGISTER_MODE_JUMP_TABLE,A3
00001200  3638 0600                228      MOVE    SOURCE_MODE,D3
00001204  C6FC 0006                229      MULU    #6,D3
00001208  4EB3 3000                230      JSR     0(A3,D3)       * Let's see what mode is this source mode
0000120C                           231  
0000120C                           232  
0000120C                           233  PRINT_COMMA *Print the comma to separate between source and destination
0000120C  43F9 0000138A            234      LEA     COMMA,A1
00001212  103C 000E                235      MOVE.B  #14,D0
00001216  4E4F                     236      TRAP #15
00001218  4E75                     237      RTS
0000121A                           238  
0000121A                           239  
0000121A                           240  
0000121A                           241  
0000121A                           242  
0000121A                           243  
0000121A                           244  
0000121A                           245  
0000121A                           246  
0000121A                           247  
0000121A                           248  
0000121A                           249  
0000121A                           250  
0000121A                           251  
0000121A                           252  
0000121A                           253  
0000121A                           254  
0000121A                           255  
0000121A                           256  
0000121A                           257  
0000121A                           258  
0000121A                           259  FIRST_BYTE_IS_5
0000121A  4E75                     260      RTS
0000121C  FFFF FFFF                261      SIMHALT
00001220                           262  FIRST_BYTE_IS_6
00001220  4E75                     263      RTS
00001222  FFFF FFFF                264      SIMHALT
00001226                           265  FIRST_BYTE_IS_7
00001226  4E75                     266      RTS
00001228  FFFF FFFF                267      SIMHALT
0000122C                           268  FIRST_BYTE_IS_8
0000122C  4E75                     269      RTS
0000122E  FFFF FFFF                270      SIMHALT
00001232                           271  FIRST_BYTE_IS_9
00001232  4E75                     272      RTS
00001234  FFFF FFFF                273      SIMHALT
00001238                           274  FIRST_BYTE_IS_A
00001238  4E75                     275      RTS
0000123A  FFFF FFFF                276      SIMHALT
0000123E                           277  FIRST_BYTE_IS_B
0000123E  4E75                     278      RTS
00001240  FFFF FFFF                279      SIMHALT
00001244                           280  FIRST_BYTE_IS_C
00001244  4E75                     281      RTS
00001246  FFFF FFFF                282      SIMHALT
0000124A                           283  FIRST_BYTE_IS_D
0000124A  4E75                     284      RTS
0000124C  FFFF FFFF                285      SIMHALT
00001250                           286  FIRST_BYTE_IS_E
00001250  4E75                     287      RTS
00001252  FFFF FFFF                288      SIMHALT
00001256                           289  FIRST_BYTE_IS_F
00001256  4E75                     290      RTS
00001258  FFFF FFFF                291      SIMHALT
0000125C                           292  
0000125C                           293  
0000125C                           294  FIRST_BYTE_4_SECOND_BYTE_E        * Possible answer are NOP,JSR and RTS
0000125C  3638 0300                295      MOVE.W  TEMP_VAR,D3       * Get the op code
00001260  E14B                     296      LSL     #8,D3             * Shift to the left to dissappear 2 left most byte
00001262  E04B                     297      LSR     #8,D3             * Shift to the right to gain back original position. Only now the 2 left most byte are gone
00001264  B63C 0071                298      CMP.B   #$71,D3           * NOP is 4E71
00001268  6700 002C                299      BEQ     PRINT_OUT_NOP
0000126C  B63C 0075                300      CMP.B   #$75,D3           *RTS is 4E75
00001270  6700 003A                301      BEQ     PRINT_OUT_RTS
00001274                           302  
00001274                           303  
00001274                           304  
00001274                           305  
00001274                           306  
00001274                           307  
00001274                           308  SECOND_BYTE_IS_0 * Possible to be ORI. In the case first byte is 0 as well
00001274  161A                     309      MOVE.B  (A2)+,D3
00001276  B63C 007C                310      CMP.B   #$7C,D3            * Only ORI to SR have the last 2 bytes in op code as 7C
0000127A  6000 0046                311      BRA     PRINT_OUT_ORI_TO_SR
0000127E                           312  
0000127E                           313  FINISH_ONE_INSTRUCTION
0000127E  544A                     314      ADD #2,A2 *Move to the next instruction
00001280  6000 FDAA                315      BRA PARSING_OP_CODE
00001284                           316  
00001284                           317  SECOND_BYTE_IS_E  * Possible to be NOP and RTS. In the case the first byte is 4
00001284  161A                     318      MOVE.B  (A2)+,D3   * Get the remaning 2 bytes
00001286  B67C 0071                319      CMP     #$71,D3
0000128A  6700 000A                320      BEQ     PRINT_OUT_NOP
0000128E  B67C 0075                321      CMP     #$75,D3
00001292  6700 0018                322      BEQ     PRINT_OUT_RTS
00001296                           323  
00001296                           324  PRINT_OUT_NOP
00001296  43F9 0000136A            325      LEA     NOP_VALUE,A1 * Display the NOP message
0000129C  103C 000D                326      MOVE.B  #13,D0
000012A0  4E4F                     327      TRAP    #15
000012A2  6100 002A                328      BSR     USER_INPUT_ENTER
000012A6  60D6                     329      BRA     FINISH_ONE_INSTRUCTION
000012A8  FFFF FFFF                330      SIMHALT             ; halt simulator
000012AC                           331  
000012AC                           332  PRINT_OUT_RTS
000012AC  43F9 00001370            333      LEA     RTS_VALUE,A1
000012B2  103C 000D                334      MOVE.B  #13,D0
000012B6  4E4F                     335      TRAP    #15
000012B8  6100 0014                336      BSR USER_INPUT_ENTER
000012BC  60C0                     337      BRA FINISH_ONE_INSTRUCTION
000012BE  FFFF FFFF                338      SIMHALT
000012C2                           339  
000012C2                           340  PRINT_OUT_ORI_TO_SR
000012C2  43F9 00001376            341      LEA     ORI_VALUE,A1
000012C8  103C 000E                342      MOVE.B  #14,D0
000012CC  4E4F                     343      TRAP    #15
000012CE                           344  
000012CE                           345  
000012CE                           346  
000012CE                           347  USER_INPUT_ENTER  * Wait for the user to press enter to continue
000012CE  103C 0004                348      MOVE.B  #4,D0
000012D2  4E4F                     349      TRAP #15
000012D4  4E75                     350      RTS
000012D6                           351  
000012D6                           352  
000012D6                           353  
000012D6                           354  
000012D6                           355  
000012D6                           356  REGISTER_MODE_000
Line 357 ERROR: Invalid syntax
000012D6                           357      LEA 
000012D6                           358  
000012D6                           359  
000012D6                           360  
000012D6                           361  
000012D6                           362  
000012D6                           363  REGISTER_MODE_001
000012D6                           364  REGISTER_MODE_010
000012D6                           365  REGISTER_MODE_011
000012D6                           366  REGISTER_MODE_100
000012D6                           367  REGISTER_MODE_101
000012D6                           368  REGISTER_MODE_110
000012D6                           369  REGISTER_MODE_111
000012D6                           370  
000012D6                           371  
000012D6                           372  
000012D6                           373  
000012D6                           374  
000012D6                           375  
000012D6                           376  
000012D6                           377  
000012D6                           378  
000012D6                           379  
000012D6                           380  
000012D6                           381  * Put variables and constants here
000012D6                           382  
000012D6= 5765 6C63 6F6D 6...      383  INTRO_STARTING   DC.W   'Welcome to the Disassembler. Please enter starting address',0
00001312= 506C 6561 7365 2...      384  INTRO_ENDING     DC.W   'Please enter ending address',0
00001330= 494E 5641 4C49 4...      385  INVALID_INPUT    DC.W   'INVALID ADDRESS ENTERED. PLEASE ONLY ENTER 0 - 9 AND A-F',0
0000136A= 4E4F 5000 0000           386  NOP_VALUE        DC.W   'NOP',0
00001370= 5254 5300 0000           387  RTS_VALUE        DC.W   'RTS',0
00001376= 4F52 4900 0000           388  ORI_VALUE        DC.W   'ORI',0
0000137C= 5352 0000                389  SR_VALUE         DC.W   'SR',0
00001380= 4343 5200 0000           390  CCR_VALUE        DC.W   'CCR',0
00001386= 4400 0000                391  DATA_REGISTER    DC.W   'D',0
0000138A= 2C00 0000                392  COMMA            DC.W   ',',0
0000138E  =00004E71                393  NOP             EQU      $4E71
0000138E                           394  
0000138E                           395  
0000138E                           396  
0000138E                           397  
0000138E                           398  
0000138E                           399  
0000138E                           400  
0000138E                           401  
0000138E                           402  
0000138E                           403  
0000138E                           404      END    START        ; last line of source

1 error detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
CCR_VALUE           1380
CHECK_TYPE_DATA     11A4
COMMA               138A
CONVERT_ASCII_TO_HEX  10E2
CONVERT_CHARACTER_ASCII_TO_HEX  1114
DATA_REGISTER       1386
DESTINATION_MODE    500
DESTINATION_VAR     400
ENDING_ADDRESS      200
ERROR_INVALID_INPUT  1104
FINISH_CONVERT_ENDING_ADDRESS  1148
FINISH_CONVERT_STARTING_ADDRESS  1134
FINISH_ONE_INSTRUCTION  127E
FIRST_BYTE_4_SECOND_BYTE_E  125C
FIRST_BYTE_IS_0     1158
FIRST_BYTE_IS_1     1164
FIRST_BYTE_IS_2     116A
FIRST_BYTE_IS_3     1170
FIRST_BYTE_IS_4     1176
FIRST_BYTE_IS_5     121A
FIRST_BYTE_IS_6     1220
FIRST_BYTE_IS_7     1226
FIRST_BYTE_IS_8     122C
FIRST_BYTE_IS_9     1232
FIRST_BYTE_IS_A     1238
FIRST_BYTE_IS_B     123E
FIRST_BYTE_IS_C     1244
FIRST_BYTE_IS_D     124A
FIRST_BYTE_IS_E     1250
FIRST_BYTE_IS_F     1256
FIRST_BYTE_JUMP_TABLE  1052
GET_END_ADDRESS     1016
GET_START_ADDRESS   1000
INTRO_ENDING        1312
INTRO_STARTING      12D6
INVALID             1190
INVALID_INPUT       1330
NEG_OR_LEA          1190
NOP                 4E71
NOP_VALUE           136A
ORI_VALUE           1376
PARSING_OP_CODE     102C
PREPARE_START_AND_END_ADDRESS  1042
PRINT_COMMA         120C
PRINT_DATA_MODE     11FC
PRINT_LEA           11E6
PRINT_OUT_NOP       1296
PRINT_OUT_ORI_TO_SR  12C2
PRINT_OUT_RTS       12AC
REGISTER_MODE_000   12D6
REGISTER_MODE_001   12D6
REGISTER_MODE_010   12D6
REGISTER_MODE_011   12D6
REGISTER_MODE_100   12D6
REGISTER_MODE_101   12D6
REGISTER_MODE_110   12D6
REGISTER_MODE_111   12D6
REGISTER_MODE_JUMP_TABLE  10B2
RTS_VALUE           1370
SECOND_BYTE_IS_0    1274
SECOND_BYTE_IS_E    1284
SOURCE_MODE         600
SOURCE_VAR          700
SR_VALUE            137C
START               1000
STARTING_ADDRESS    100
TEMP_VAR            300
USER_INPUT_ENTER    12CE
