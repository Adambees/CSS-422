00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 3/15/2018 3:11:13 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : 68k Disassembler
00000000                             3  * Written by : Thuan Tran
00000000                             4  * Date       : March 11th, 2018
00000000                             5  * Description: Load a test file, enter starting and ending address. Press enter to see it disassemble every line
00000000                             6  *-----------------------------------------------------------
00000000                             7  
00000000                             8  *** A2 will be used as the address in which it will iterate through all the way until ending adrress
00000000                             9  *** A3 will be used to store the ending address
00000000                            10  
00000000  =00000100                 11  STARTING_ADDRESS            EQU    $100 * User input starting address
00000000  =00000150                 12  ENDING_ADDRESS              EQU    $150 * User input ending address
00000000  =00000200                 13  TEMP_CURRENT_4_NIBBLES      EQU    $200 * Temporary variable to hold 4 nibble at a time
00000000  =00000250                 14  DESTINATION_VAR             EQU    $250 * Used to hold the Address number     (11-9th bit)
00000000  =00000300                 15  DESTINATION_MODE            EQU    $300 * Used to hold the mode of destination (8-6 bit)
00000000  =00000350                 16  SOURCE_MODE                 EQU    $350 * used to hold the mode of the source (5-3)
00000000  =00000400                 17  SOURCE_VAR                  EQU    $400 * Used to hold the address number of source (2-0 bit)
00000000  =00000550                 18  THIRD_TEMP_VAR              EQU    $550 * Used as an arbitrary storage for data
00000000  =00000600                 19  FOURTH_TEMP_VAR             EQU    $600 * Used to prevent overwrite to (A1) when getting end address
00000000  =00000650                 20  FIFTH_TEMP_VAR              EQU    $650 * Used to prevent overwrite to (A1) when getting start address
00000000  =00000750                 21  TEMP_CURRENT_2_NIBBLES      EQU    $750 * Temporary variable to store 2 nibble at a time
00000000                            22  
00000000                            23  ***
00000000                            24  * Beginning of the program
00000000                            25  ***
00000000                            26  
00001000                            27      ORG    $1000
00001000                            28  START:                  ; first instruction of program
00001000                            29  
00001000                            30  ********************************************************************************
00001000                            31  *****************************************
00001000                            32  * Start of input and parsing op code section
00001000                            33  *****************************************
00001000                            34  ********************************************************************************
00001000                            35  
00001000                            36  ***
00001000                            37  * Display welcome prompt to user and ask for starting address
00001000                            38  ***
00001000                            39  GET_START_ADDRESS
00001000  43F9 0000216E             40      LEA         INTRO_STARTING,A1                       * Welcome the user
00001006  103C 000D                 41      MOVE.B      #13,D0                                  * Nice to have carry and line feed
0000100A  4E4F                      42      TRAP        #15
0000100C  227C 00000000             43      MOVEA.L     #0,A1                                   * Clear what is in A1
00001012  43F8 0650                 44      LEA         FIFTH_TEMP_VAR,A1                       * This was made so that when we read a string, it won't overide (A1)
00001016  4240                      45      CLR         D0
00001018  4241                      46      CLR         D1
0000101A  103C 0002                 47      MOVE.B      #2,D0                                   * Get a string input that represent the user
0000101E  4E4F                      48      TRAP        #15
00001020  6000 003E                 49      BRA         CONVERT_ASCII_TO_HEX
00001024                            50  
00001024                            51  ***
00001024                            52  * Display prompt to user and ask for ending address
00001024                            53  ***
00001024                            54  GET_END_ADDRESS
00001024  43F9 0000218E             55      LEA         INTRO_ENDING,A1                         * Now time to get the ending address
0000102A  103C 000D                 56      MOVE.B      #13,D0
0000102E  4E4F                      57      TRAP        #15
00001030  43F8 0600                 58      LEA         FOURTH_TEMP_VAR,A1                      *Same like get starting address
00001034  103C 0002                 59      MOVE.B      #2,D0
00001038  4E4F                      60      TRAP        #15
0000103A  6000 0024                 61      BRA         CONVERT_ASCII_TO_HEX
0000103E                            62  
0000103E                            63  ***
0000103E                            64  * Parsing 4 nibbles sequentially and decoding them based on the first nibble (left most)
0000103E                            65  ***
0000103E                            66  PARSING_OP_CODE
0000103E  4EB9 00001932             67      JSR         PRINT_ADDRESS_LOCATION
00001044  4EB9 000019EA             68      JSR         GET_NEXT_FOUR_NIBBLE
0000104A  3638 0200                 69      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
0000104E  4EB9 000019CA             70      JSR         GET_THE_FIRST_NIBBLE
00001054  C6FC 0006                 71      MULU        #6,D3                                   * Get the index
00001058  4EB0 3000                 72      JSR         0(A0,D3)                                * Jump to the table depemding on first nibble
0000105C  FFFF FFFF                 73      SIMHALT
00001060                            74  
00001060                            75  ***
00001060                            76  *This is called during the first part of program, when trying to convert user starting and ending address
00001060                            77  * Convert 0-9 and A-F in ASCII to Hex Value
00001060                            78  *ascii table http://www.asciitable.com/
00001060                            79  ***
00001060                            80  CONVERT_ASCII_TO_HEX
00001060  1019                      81      MOVE.B      (A1)+,D0                                * Go through each byte of the address
00001062  B03C 0030                 82      CMP.B       #$30,D0                                 * Valid data are from $30 - $39 ( 0-9) and $41 - $46 (A-F)
00001066  6D00 00B8                 83      BLT         ERROR_INVALID_INPUT
0000106A  B03C 0039                 84      CMP.B       #$39,D0                                 * check if in the range number of hex character
0000106E  6E00 0016                 85      BGT         CONVERT_CHARACTER_ASCII_TO_HEX
00001072  0400 0030                 86      SUB.B       #$30,D0                                 * Get the hex range from '0-9'
00001076  D680                      87      ADD.L       D0,D3
00001078  5341                      88      SUBI        #1,D1                                   * Decrement the counter for length of address
0000107A  B23C 0000                 89      CMP.B       #0,D1
0000107E  6700 002A                 90      BEQ         FINISH_CONVERT_STARTING_ADDRESS
00001082  E98B                      91      LSL.L       #4,D3                                   * Get space for next nibble
00001084  60DA                      92      BRA         CONVERT_ASCII_TO_HEX
00001086                            93  
00001086                            94  ***
00001086                            95  * Convert A-F in ASCII to hex value
00001086                            96  ***
00001086                            97  CONVERT_CHARACTER_ASCII_TO_HEX
00001086  B03C 0041                 98      CMP.B       #$41,D0                                 * At this point, the data must be larger than number
0000108A  6D00 0094                 99      BLT         ERROR_INVALID_INPUT                     * Only $41 - 46 are valid
0000108E  B03C 0046                100      CMP.B       #$46,D0
00001092  6E00 008C                101      BGT         ERROR_INVALID_INPUT                     * Greater than $46, nope
00001096  0400 0037                102      SUB.B       #$37,D0                                 * Get the A-F value
0000109A  D680                     103      ADD.L       D0,D3                                   * Save the value
0000109C  5341                     104      SUBI        #1,D1                                   * Decrement the counter
0000109E  B23C 0000                105      CMP.B       #0,D1
000010A2  6700 0006                106      BEQ         FINISH_CONVERT_STARTING_ADDRESS
000010A6  E98B                     107      LSL.L       #4,D3                                   * Shift the value to the left 4 bits to save room for another nibble
000010A8  60B6                     108      BRA         CONVERT_ASCII_TO_HEX
000010AA                           109  
000010AA                           110  ***
000010AA                           111  *   Save the starting addres to an appropriate place and also test if it is valid
000010AA                           112  ***
000010AA                           113  FINISH_CONVERT_STARTING_ADDRESS
000010AA  0803 0000                114      BTST        #0,D3                                   * Test last bit of the address to see if it is even or odd
000010AE  6600 0040                115      BNE         INVALID_STARTING_ADDRESS
000010B2  B47C 0001                116      CMP         #1,D2                                   * Check if we are doing starting or ending address
000010B6  6700 000C                117      BEQ         FINISH_CONVERT_ENDING_ADDRESS
000010BA  5242                     118      ADDI        #1,D2                                   * Counter to make sure that we are doing the ending address
000010BC  21C3 0100                119      MOVE.L      D3,STARTING_ADDRESS
000010C0  6000 FF62                120      BRA         GET_END_ADDRESS
000010C4                           121  
000010C4                           122  ***
000010C4                           123  * Save the ending address to an appropriate place and also test if it is valid
000010C4                           124  ***
000010C4                           125  FINISH_CONVERT_ENDING_ADDRESS
000010C4  0803 0000                126      BTST        #0,D3                                   * Check for odd address
000010C8  6600 003E                127      BNE         INVALID_ENDING_ADDRESS
000010CC  B6B8 0100                128      CMP.L       STARTING_ADDRESS, D3                    * Check if the ending address is less than or equal starting address
000010D0  6F00 0036                129      BLE         INVALID_ENDING_ADDRESS
000010D4  4242                     130      CLR.W       D2                                      * Clear the second data register for future use
000010D6  21C3 0150                131      MOVE.L      D3,ENDING_ADDRESS
000010DA  4243                     132      CLR.W       D3
000010DC  43F9 000022F6            133      LEA         SPACE,A1
000010E2  103C 000D                134      MOVE.B      #13,D0
000010E6  4E4F                     135      TRAP        #15
000010E8  6000 0090                136      BRA         PREPARE_START_AND_END_ADDRESS
000010EC  FFFF FFFF                137      SIMHALT
000010F0                           138  
000010F0                           139  ***
000010F0                           140  * Display the prompt invalid and ask user to enter again for invalid starting address
000010F0                           141  ***
000010F0                           142  INVALID_STARTING_ADDRESS
000010F0  227C 00000000            143      MOVEA.L     #0,A1
000010F6  43F9 000021AC            144      LEA         INVALID_INPUT,A1
000010FC  103C 000D                145      MOVE.B      #13,D0
00001100  4E4F                     146      TRAP        #15
00001102  4243                     147      CLR         D3
00001104  6000 FEFA                148      BRA         GET_START_ADDRESS
00001108                           149  
00001108                           150  ***
00001108                           151  * Display the prompt invalid and ask user to enter again for ending address
00001108                           152  ***
00001108                           153  INVALID_ENDING_ADDRESS
00001108  227C 00000000            154      MOVEA.L     #0,A1
0000110E  43F9 000021AC            155      LEA         INVALID_INPUT,A1
00001114  103C 000D                156      MOVE.B      #13,D0
00001118  4E4F                     157      TRAP        #15
0000111A  4243                     158      CLR         D3
0000111C  6000 FF06                159      BRA         GET_END_ADDRESS
00001120                           160  
00001120                           161  ***
00001120                           162  * Used to direct invalid address entered either to invalid starting or ending address
00001120                           163  ***
00001120                           164  ERROR_INVALID_INPUT
00001120  B47C 0001                165      CMP         #1,D2
00001124  67E2                     166      BEQ         INVALID_ENDING_ADDRESS
00001126  60C8                     167      BRA         INVALID_STARTING_ADDRESS
00001128                           168  
00001128                           169  ***
00001128                           170  * This is usally called during the program's execution.
00001128                           171  * Used for printing out address location, immediate data, absolute short and long ,..etc
00001128                           172  * Print out each nibble at a time (4 nibbles total)
00001128                           173  ***
00001128                           174  CONVERT_HEX_TO_ASCII
00001128  49F9 00001E4A            175      LEA         HEX_CHARACTER_JUMP_TABLE,A4             * Load the table to print out ascii charracter
0000112E  3638 0200                176      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001132  4EB9 000019CA            177      JSR         GET_THE_FIRST_NIBBLE                    * Get the left most hex value and convert
00001138  C6FC 0006                178      MULU        #6,D3
0000113C  4EB4 3000                179      JSR         0(A4,D3)
00001140  3638 0200                180      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001144  4EB9 000019D0            181      JSR         GET_THE_SECOND_NIBBLE
0000114A  C6FC 0006                182      MULU        #6,D3
0000114E  4EB4 3000                183      JSR         0(A4,D3)
00001152  3638 0200                184      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001156  4EB9 000019D8            185      JSR         GET_THE_THIRD_NIBBLE
0000115C  C6FC 0006                186      MULU        #6,D3
00001160  4EB4 3000                187      JSR         0(A4,D3)
00001164  3638 0200                188      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001168  4EB9 000019E0            189      JSR         GET_THE_FOURTH_NIBBLE
0000116E  C6FC 0006                190      MULU        #6,D3
00001172  4EB4 3000                191      JSR         0(A4,D3)
00001176  4243                     192      CLR.W       D3
00001178  4E75                     193      RTS
0000117A                           194  
0000117A                           195  
0000117A                           196  ***
0000117A                           197  * Called when starting and ending address was entered and converted correctly
0000117A                           198  ***
0000117A                           199  PREPARE_START_AND_END_ADDRESS
0000117A  41F9 00001AA0            200      LEA         FIRST_NIBBLE_JUMP_TABLE,A0              * Prepare the jump table for first nibble decoding
00001180  2478 0100                201      MOVE.L      STARTING_ADDRESS,A2
00001184  2678 0150                202      MOVE.L      ENDING_ADDRESS,A3
00001188  6000 FEB4                203      BRA         PARSING_OP_CODE                         * Start parsing the opcode now
0000118C                           204  
0000118C                           205  ***
0000118C                           206  * Wait for the user to press enter to continue
0000118C                           207  ***
0000118C                           208  USER_INPUT_ENTER
0000118C  103C 0005                209      MOVE.B      #5,D0
00001190  4E4F                     210      TRAP        #15
00001192  4E75                     211      RTS
00001194                           212  
00001194                           213  
00001194                           214  ********************************************************************************
00001194                           215  *********************************************
00001194                           216  * Print the decoded opcode and data to console
00001194                           217  * This section will also be the place where most of the logic is done
00001194                           218  *********************************************
00001194                           219  ********************************************************************************
00001194                           220  
00001194                           221  
00001194                           222  ***
00001194                           223  * Called when an invalid instructions or data accessing mode was encounterd
00001194                           224  ***
00001194                           225  INVALID
00001194  43F9 000022BA            226      LEA         DATA_VALUE,A1
0000119A  4EB9 000018F6            227      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
000011A0  4EB9 000019B2            228      JSR         PRINT_EMPTY_SPACE
000011A6  4EB9 000019A6            229      JSR         PRINT_HEX_SYMBOL
000011AC  4EB8 1128                230      JSR         CONVERT_HEX_TO_ASCII                    * Print out the op code that was not decoded
000011B0  43F9 000022F6            231      LEA         SPACE,A1 * Go to new line
000011B6  103C 000E                232      MOVE.B      #14,D0
000011BA  4E4F                     233      TRAP        #15
000011BC  61CE                     234      BSR         USER_INPUT_ENTER
000011BE  6000 FE7E                235      BRA         PARSING_OP_CODE                         * Get the next four nibbles and parsing
000011C2                           236  
000011C2                           237  ***
000011C2                           238  * Print out the NEG Instruction with only 1 operands to follow
000011C2                           239  ***
000011C2                           240  PRINT_OUT_NEG
000011C2  3638 0200                241      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
000011C6  4EB9 00001A00            242      JSR         GET_NORMAL_SIZE
000011CC  B67C 0003                243      CMP         #%11,D3
000011D0  67C2                     244      BEQ         INVALID                                 * NEG can only have normal size ,01,00,10
000011D2  43F9 00002232            245      LEA         NEG_VALUE,A1                            * Print NEG to screen
000011D8  4EB9 000018F6            246      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
000011DE  4EB9 000012D4            247      JSR         PRINT_NORMAL_SUFFIX
000011E4  3638 0200                248      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
000011E8  4EB9 00001A22            249      JSR         CHECK_TYPE_DATA                         * Extract the mode and register
000011EE  4EB9 000018FE            250      JSR         PRINT_DATA_MODE_SOURCE
000011F4  6196                     251      BSR         USER_INPUT_ENTER
000011F6  6000 FE46                252      BRA         PARSING_OP_CODE
000011FA  4E75                     253      RTS
000011FC                           254  
000011FC                           255  ***
000011FC                           256  * Print out the NOP instructions with no operands to follow
000011FC                           257  ***
000011FC                           258  PRINT_OUT_NOP
000011FC  43F9 00002214            259      LEA         NOP_VALUE,A1 * Display the NOP message
00001202  4EB9 000018F6            260      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001208  6182                     261      BSR         USER_INPUT_ENTER
0000120A  6000 FE32                262      BRA         PARSING_OP_CODE
0000120E  4E75                     263      RTS
00001210                           264  
00001210                           265  ***
00001210                           266  * Print out the RTS instruction with no operands to follow
00001210                           267  ***
00001210                           268  PRINT_OUT_RTS
00001210  43F9 0000221A            269      LEA         RTS_VALUE,A1
00001216  4EB9 000018F6            270      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
0000121C  6100 FF6E                271      BSR         USER_INPUT_ENTER
00001220  6000 FE1C                272      BRA         PARSING_OP_CODE
00001224  4E75                     273      RTS
00001226                           274  
00001226                           275  ***
00001226                           276  * Print out the ORI to SR instruction
00001226                           277  * Unfinished implementation
00001226                           278  ***
00001226                           279  PRINT_OUT_ORI_TO_SR
00001226  43F9 00002220            280      LEA         ORI_VALUE,A1
0000122C  4EB9 000018F6            281      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001232  6100 FF58                282      BSR         USER_INPUT_ENTER
00001236  6000 FE06                283      BRA         PARSING_OP_CODE
0000123A  4E75                     284      RTS
0000123C                           285  
0000123C                           286  ***
0000123C                           287  * Print out the JSR instructions with the address to jump to
0000123C                           288  * This will print out the actual address, not just the displacement
0000123C                           289  ***
0000123C                           290  PRINT_OUT_JSR
0000123C  43F9 00002226            291      LEA         JSR_VALUE,A1
00001242  4EB9 000018F6            292      JSR         PRINT_TO_SCREEN_ENTIRE_STRING           * Now query what type of data to print out, source or destination
00001248  4EB9 000019B2            293      JSR         PRINT_EMPTY_SPACE
0000124E  3638 0200                294      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001252  4EB9 00001A22            295      JSR         CHECK_TYPE_DATA
00001258  4EB9 000018FE            296      JSR         PRINT_DATA_MODE_SOURCE                  * Print the M and N of the last 6 bits
0000125E  6100 FF2C                297      BSR         USER_INPUT_ENTER
00001262  6000 FDDA                298      BRA         PARSING_OP_CODE
00001266                           299  
00001266                           300  ***
00001266                           301  * Print out the CMPI instruction
00001266                           302  ***
00001266                           303  PRINT_OUT_CMPI
00001266  43F9 00002238            304      LEA         CMPI_VALUE,A1                           * Print out the literal value
0000126C  4EB9 000018F6            305      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001272  3638 0200                306      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001276  4EB9 00001A22            307      JSR         CHECK_TYPE_DATA
0000127C  4EB9 000012D4            308      JSR         PRINT_NORMAL_SUFFIX
00001282  4EB9 000019B2            309      JSR         PRINT_EMPTY_SPACE
00001288  4EB9 000019BE            310      JSR         PRINT_IMMEDIATE_DATA_SYMBOL
0000128E  4EB9 00001A00            311      JSR         GET_NORMAL_SIZE                         * Get the size of the operation to know how much byte should we advance forward
00001294  E24B                     312      LSR         #1, D3                                  * For cmpi.b and cmpi.w, they all map to absolute short in which print only 4
00001296  31C3 0550                313      MOVE.W      D3, THIRD_TEMP_VAR
0000129A  4EB9 00001A22            314      JSR         CHECK_TYPE_DATA                         * Now byte and word will be printed 4 space where as long will be printed 5 space
000012A0  4EB9 00001D82            315      JSR         REGISTER_MODE_111                       * Print out the immediate value
000012A6  4EB9 00001952            316      JSR         PRINT_COMMA
000012AC  4EB9 000019B2            317      JSR         PRINT_EMPTY_SPACE
000012B2  4EB9 000018FE            318      JSR         PRINT_DATA_MODE_SOURCE
000012B8  6100 FED2                319      BSR         USER_INPUT_ENTER
000012BC  6000 FD80                320      BRA         PARSING_OP_CODE
000012C0  4E75                     321      RTS
000012C2                           322  
000012C2                           323  ***
000012C2                           324  * Print the suffix that represent size within the opcode
000012C2                           325  * This is only used for MOVE and MOVEM instructions where the size for byte, word ,long are 01,11,10
000012C2                           326  ***
000012C2                           327  PRINT_NOT_NORMAL_SUFFIX
000012C2  49F9 00001FB8            328      LEA         NORMAL_SIZE_PRINT_JUMP_TABLE,A4
000012C8  C6FC 0006                329      MULU        #6,D3
000012CC  4EB4 3000                330      JSR         0(A4,D3)
000012D0  4243                     331      CLR         D3
000012D2  4E75                     332      RTS
000012D4                           333  
000012D4                           334  ***
000012D4                           335  * Print the suffix that represent the NORMAL size within the op code
000012D4                           336  * The normal size are usually found at the first 2 bit at the third nibble
000012D4                           337  * For byte, word, long, the size are : 00,01,10
000012D4                           338  ***
000012D4                           339  PRINT_NORMAL_SUFFIX
000012D4  3638 0200                340      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
000012D8  4EB9 00001A00            341      JSR         GET_NORMAL_SIZE
000012DE  49F9 00001FB8            342      LEA         NORMAL_SIZE_PRINT_JUMP_TABLE,A4
000012E4  B67C 0003                343      CMP         #%11,D3                                 * For normal size, does not take 11
000012E8  6700 FEAA                344      BEQ         INVALID
000012EC  C6FC 0006                345      MULU        #6,D3
000012F0  4EB4 3000                346      JSR         0(A4,D3)                                * Print out appropriate suffix
000012F4  4E75                     347      RTS
000012F6                           348  
000012F6                           349  ***
000012F6                           350  * Print out the register number (Xn)
000012F6                           351  * Need to put the register number into THIRD_TEMP_VAR first
000012F6                           352  * Could be the data source or data destination that call this method
000012F6                           353  ***
000012F6                           354  
000012F6                           355  PRINT_REGISTER_NUMBER
000012F6  49F9 00001E4A            356      LEA         HEX_CHARACTER_JUMP_TABLE,A4
000012FC  3638 0550                357      MOVE.W      THIRD_TEMP_VAR,D3
00001300  C6FC 0006                358      MULU        #6,D3
00001304  4EB4 3000                359      JSR         0(A4,D3)
00001308  4278 0550                360      CLR.W       THIRD_TEMP_VAR
0000130C  4243                     361      CLR.W       D3
0000130E  4E75                     362      RTS
00001310                           363  
00001310                           364  ***
00001310                           365  * Print out the LEA instruction
00001310                           366  ***
00001310                           367  PRINT_OUT_LEA
00001310  43F9 0000222C            368      LEA         LEA_VALUE,A1
00001316  4EB9 000018F6            369      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
0000131C  4EB9 000019B2            370      JSR         PRINT_EMPTY_SPACE
00001322  3638 0200                371      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001326  4EB9 00001A22            372      JSR         CHECK_TYPE_DATA
0000132C  4EB9 000018FE            373      JSR         PRINT_DATA_MODE_SOURCE
00001332  4EB9 00001952            374      JSR         PRINT_COMMA
00001338  4EB9 000019B2            375      JSR         PRINT_EMPTY_SPACE
0000133E  4EB9 0000195E            376      JSR         PRINT_ADDRESS_REGISTER                  * Already know the LEA can only take use of Address register
00001344  31F8 0250 0550           377      MOVE.W      DESTINATION_VAR,THIRD_TEMP_VAR          * Store the register number to print
0000134A  4EB8 12F6                378      JSR         PRINT_REGISTER_NUMBER
0000134E  6100 FE3C                379      BSR         USER_INPUT_ENTER
00001352  6000 FCEA                380      BRA         PARSING_OP_CODE
00001356  4E75                     381      RTS
00001358                           382  
00001358                           383  ***
00001358                           384  * Print out the ADDQ instruction
00001358                           385  * Utilized a helper method because ADDQ and SUBQ are the same
00001358                           386  ***
00001358                           387  PRINT_OUT_ADDQ
00001358  43F9 00002280            388      LEA         ADDQ_VALUE,A1
0000135E  6000 000C                389      BRA         ADDQ_AND_SUBQ_HELPER
00001362                           390  
00001362                           391  ***
00001362                           392  * Print out the SUBQ instruction
00001362                           393  * Utilized a helper method because ADDQ and SUBQ are the same
00001362                           394  ***
00001362                           395  PRINT_OUT_SUBQ
00001362  43F9 00002250            396      LEA         SUBQ_VALUE,A1
00001368  6000 0002                397      BRA         ADDQ_AND_SUBQ_HELPER
0000136C                           398  
0000136C                           399  ***
0000136C                           400  * Helper method for ADDQ and SUBQ
0000136C                           401  ***
0000136C                           402  ADDQ_AND_SUBQ_HELPER
0000136C  4EB9 000018F6            403      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001372  4EB8 12D4                404      JSR         PRINT_NORMAL_SUFFIX
00001376  4EB9 000019B2            405      JSR         PRINT_EMPTY_SPACE
0000137C  4EB9 000019BE            406      JSR         PRINT_IMMEDIATE_DATA_SYMBOL
00001382  3638 0200                407      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001386  4EB9 00001A22            408      JSR         CHECK_TYPE_DATA
0000138C  0C78 0000 0250           409      CMP         #0, DESTINATION_VAR                     * In the case of 8, the destination var is 000. But we want to print out 8
00001392  6700 0028                410      BEQ         SUBQ_HELPER_FUNCTION                    * If it is the case, then move to another helper to move 8 directly into it
00001396  31F8 0250 0550           411      MOVE.W      DESTINATION_VAR,THIRD_TEMP_VAR          * Save the value to print out from print register number
0000139C  4EB8 12F6                412      JSR         PRINT_REGISTER_NUMBER                   * Print out the data from 1-8
000013A0  4EB9 00001952            413      JSR         PRINT_COMMA
000013A6  4EB9 000019B2            414      JSR         PRINT_EMPTY_SPACE
000013AC  4EB9 000018FE            415      JSR         PRINT_DATA_MODE_SOURCE
000013B2  6100 FDD8                416      BSR         USER_INPUT_ENTER
000013B6  6000 FC86                417      BRA         PARSING_OP_CODE
000013BA  4E75                     418      RTS
000013BC                           419  
000013BC                           420  ***
000013BC                           421  * Helper method to print out 8 for ADDQ and SUBQ
000013BC                           422  ***
000013BC                           423  SUBQ_HELPER_FUNCTION                                    * Single function that exist to help with printing oout the data in SUBQ
000013BC  31FC 0008 0550           424      MOVE.W      #8, THIRD_TEMP_VAR
000013C2  4EB8 12F6                425      JSR         PRINT_REGISTER_NUMBER
000013C6  4EB9 00001952            426      JSR         PRINT_COMMA
000013CC  4EB9 000019B2            427      JSR         PRINT_EMPTY_SPACE
000013D2  4EB9 000018FE            428      JSR         PRINT_DATA_MODE_SOURCE
000013D8  6100 FDB2                429      BSR         USER_INPUT_ENTER
000013DC  6000 FC60                430      BRA         PARSING_OP_CODE
000013E0  4E75                     431      RTS
000013E2                           432  
000013E2                           433  ***
000013E2                           434  * Print out the DIVS instruction
000013E2                           435  ***
000013E2                           436  PRINT_OUT_DIVS
000013E2  43F9 00002256            437      LEA         DIVS_VALUE,A1
000013E8  4EB9 000018F6            438      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
000013EE  4EB9 00001FE0            439      JSR         PRINT_NORMAL_WORD_SUFFIX                * DIVS can only take word suffix
000013F4  4EB9 000019B2            440      JSR         PRINT_EMPTY_SPACE
000013FA  4EB9 000018FE            441      JSR         PRINT_DATA_MODE_SOURCE
00001400  4EB9 00001952            442      JSR         PRINT_COMMA
00001406  4EB9 000019B2            443      JSR         PRINT_EMPTY_SPACE
0000140C  4EB9 0000196A            444      JSR         PRINT_DATA_REGISTER                     * DIVS can only use Data register
00001412  31F8 0250 0550           445      MOVE.W      DESTINATION_VAR, THIRD_TEMP_VAR         * Store the register number Dn to print out
00001418  4EB8 12F6                446      JSR         PRINT_REGISTER_NUMBER
0000141C  6100 FD6E                447      BSR         USER_INPUT_ENTER
00001420  6000 FC1C                448      BRA         PARSING_OP_CODE
00001424  4E75                     449      RTS
00001426                           450  
00001426                           451  ***
00001426                           452  * Print out the MULS instruction
00001426                           453  ***
00001426                           454  PRINT_OUT_MULS
00001426  43F9 00002268            455      LEA         MULS_VALUE,A1
0000142C  6000 0002                456      BRA         MULS_AND_MULU_HELPER
00001430                           457  
00001430                           458  ***
00001430                           459  * Helper method for MULS and MULU instruction
00001430                           460  ***
00001430                           461  MULS_AND_MULU_HELPER
00001430  4EB9 000018F6            462      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001436  4EB9 00001FE0            463      JSR         PRINT_NORMAL_WORD_SUFFIX
0000143C  4EB9 000019B2            464      JSR         PRINT_EMPTY_SPACE
00001442  3638 0200                465      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001446  4EB9 00001A22            466      JSR         CHECK_TYPE_DATA
0000144C  31FC 0001 0300           467      MOVE.W      #%01, DESTINATION_MODE                  * Change the size of to word to print out
00001452  4EB9 000018FE            468      JSR         PRINT_DATA_MODE_SOURCE
00001458  4EB9 00001952            469      JSR         PRINT_COMMA
0000145E  4EB9 000019B2            470      JSR         PRINT_EMPTY_SPACE
00001464  4EB9 0000196A            471      JSR         PRINT_DATA_REGISTER
0000146A  31F8 0250 0550           472      MOVE.W      DESTINATION_VAR,THIRD_TEMP_VAR          * Save the register number
00001470  4EB8 12F6                473      JSR         PRINT_REGISTER_NUMBER
00001474  6100 FD16                474      BSR         USER_INPUT_ENTER
00001478  6000 FBC4                475      BRA         PARSING_OP_CODE
0000147C  4E75                     476      RTS
0000147E                           477  
0000147E                           478  ***
0000147E                           479  * Print out the MULU instruction
0000147E                           480  * Utilized a helper method
0000147E                           481  ***
0000147E                           482  PRINT_OUT_MULU
0000147E  43F9 0000226E            483      LEA         MULU_VALUE,A1
00001484  60AA                     484      BRA         MULS_AND_MULU_HELPER
00001486                           485  
00001486                           486  ***
00001486                           487  * Print out the CMP instructions
00001486                           488  ***
00001486                           489  PRINT_OUT_CMP
00001486  43F9 0000223E            490      LEA         CMP_VALUE,A1
0000148C  4EB9 000018F6            491      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001492  4EB8 12D4                492      JSR         PRINT_NORMAL_SUFFIX
00001496  4EB9 000019B2            493      JSR         PRINT_EMPTY_SPACE
0000149C  3638 0200                494      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
000014A0  4EB9 00001A22            495      JSR         CHECK_TYPE_DATA
000014A6  4EB9 000018FE            496      JSR         PRINT_DATA_MODE_SOURCE
000014AC  4EB9 00001952            497      JSR         PRINT_COMMA
000014B2  4EB9 000019B2            498      JSR         PRINT_EMPTY_SPACE
000014B8  4EB9 0000196A            499      JSR         PRINT_DATA_REGISTER                     * CMP can only use Data register
000014BE  31F8 0250 0550           500      MOVE.W      DESTINATION_VAR,THIRD_TEMP_VAR
000014C4  4EB8 12F6                501      JSR         PRINT_REGISTER_NUMBER
000014C8  6100 FCC2                502      BSR         USER_INPUT_ENTER
000014CC  6000 FB70                503      BRA         PARSING_OP_CODE
000014D0  4E75                     504      RTS
000014D2                           505  
000014D2                           506  ***
000014D2                           507  * Print out the MOVEQ instructions
000014D2                           508  ***
000014D2                           509  PRINT_OUT_MOVEQ
000014D2  43F9 000022B2            510      LEA         MOVEQ_VALUE,A1
000014D8  4EB9 000018F6            511      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
000014DE  4EB9 00001FF0            512      JSR         PRINT_NORMAL_LONG_SUFFIX                * Can only use long suffix
000014E4  3238 0200                513      MOVE.W      TEMP_CURRENT_4_NIBBLES,D1               * Save the current opcode
000014E8  4EB9 000019BE            514      JSR         PRINT_IMMEDIATE_DATA_SYMBOL
000014EE  4EB9 000019A6            515      JSR         PRINT_HEX_SYMBOL
000014F4  3638 0200                516      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
000014F8  E14B                     517      LSL         #8,D3
000014FA  E04B                     518      LSR         #8,D3
000014FC  31C3 0200                519      MOVE.W      D3, TEMP_CURRENT_4_NIBBLES              * Get the last 2 nibbles that represents that data to print out
00001500  4EB8 1128                520      JSR         CONVERT_HEX_TO_ASCII                    * Print the 8 bit data field
00001504  31C1 0200                521      MOVE.W      D1, TEMP_CURRENT_4_NIBBLES
00001508  3638 0200                522      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3               * Restore the data
0000150C  4EB9 00001952            523      JSR         PRINT_COMMA
00001512  4EB9 000019B2            524      JSR         PRINT_EMPTY_SPACE
00001518  3638 0200                525      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
0000151C  4EB9 00001A22            526      JSR         CHECK_TYPE_DATA
00001522  4EB9 0000196A            527      JSR         PRINT_DATA_REGISTER                     * Can only use Data Register
00001528  31F8 0250 0550           528      MOVE.W      DESTINATION_VAR, THIRD_TEMP_VAR         * Store the register number to print out
0000152E  4EB8 12F6                529      JSR         PRINT_REGISTER_NUMBER
00001532  6100 FC58                530      BSR         USER_INPUT_ENTER
00001536  6000 FB06                531      BRA         PARSING_OP_CODE
0000153A                           532  
0000153A                           533  ***
0000153A                           534  * Print out SUBA instruction
0000153A                           535  * Utilied a helper method
0000153A                           536  ***
0000153A                           537  PRINT_OUT_SUBA
0000153A  43F9 0000224A            538      LEA         SUBA_VALUE,A1
00001540  6000 000C                539      BRA         SUBA_AND_ADDA_HELPER
00001544                           540  
00001544                           541  ***
00001544                           542  * Print out ADDA instrucion
00001544                           543  * Utilized a helper method
00001544                           544  ***
00001544                           545  PRINT_OUT_ADDA
00001544  43F9 0000227A            546      LEA         ADDA_VALUE,A1
0000154A  6000 0002                547      BRA         SUBA_AND_ADDA_HELPER
0000154E                           548  
0000154E                           549  ***
0000154E                           550  * Helper method for ADDA ans SUBA
0000154E                           551  ***
0000154E                           552  SUBA_AND_ADDA_HELPER
0000154E  4EB9 000018F6            553      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001554  3638 0200                554      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001558  4EB9 00001A22            555      JSR         CHECK_TYPE_DATA
0000155E  4EB9 000019D0            556      JSR         GET_THE_SECOND_NIBBLE
00001564  E14B                     557      LSL         #8,D3                                   * Get the special one bit size of ADDA and SUBA
00001566  EF4B                     558      LSL         #7,D3
00001568  EE4B                     559      LSR         #7,D3
0000156A  E04B                     560      LSR         #8,D3
0000156C  5243                     561      ADD         #1,D3                                   * 0 is word and 1 is long. Add 1 will be 01 and 10, word and long for normal size
0000156E  4EB8 12C2                562      JSR         PRINT_NOT_NORMAL_SUFFIX                 * Now print .W or .L only
00001572  4EB9 000018FE            563      JSR         PRINT_DATA_MODE_SOURCE
00001578  4EB9 00001952            564      JSR         PRINT_COMMA
0000157E  4EB9 000019B2            565      JSR         PRINT_EMPTY_SPACE
00001584  4EB9 0000195E            566      JSR         PRINT_ADDRESS_REGISTER
0000158A  31F8 0250 0550           567      MOVE.W      DESTINATION_VAR, THIRD_TEMP_VAR         * Save the variable to print out the number of address register
00001590  4EB8 12F6                568      JSR         PRINT_REGISTER_NUMBER
00001594  6100 FBF6                569      BSR         USER_INPUT_ENTER
00001598  6000 FAA4                570      BRA         PARSING_OP_CODE
0000159C  4E75                     571      RTS
0000159E                           572  
0000159E                           573  ***
0000159E                           574  * Print out the OR instruction
0000159E                           575  * Utilized helper method of ADD and SUB
0000159E                           576  ***
0000159E                           577  PRINT_OUT_OR
0000159E  43F9 000022A0            578      LEA         OR_VALUE,A1
000015A4  6000 0016                579      BRA         ADD_AND_SUB_HELPER                      * Take advantage of the similar structure like add and sub
000015A8                           580  
000015A8                           581  ***
000015A8                           582  * Print out the ADD instruction
000015A8                           583  * Utilized a helper method
000015A8                           584  ***
000015A8                           585  PRINT_OUT_ADD           * Function similar like SUB
000015A8  43F9 00002274            586      LEA         ADD_VALUE,A1
000015AE  6000 000C                587      BRA         ADD_AND_SUB_HELPER
000015B2                           588  
000015B2                           589  ***
000015B2                           590  * Print out the SUB instructions
000015B2                           591  * Utilized a helper method
000015B2                           592  ***
000015B2                           593  PRINT_OUT_SUB
000015B2  43F9 00002244            594      LEA         SUB_VALUE,A1
000015B8  6000 0002                595      BRA         ADD_AND_SUB_HELPER
000015BC                           596  
000015BC                           597  
000015BC                           598  ***
000015BC                           599  * Helper method for SUB and ADD
000015BC                           600  * The SUB function is odd is that the Dn is always in front
000015BC                           601  * So to distinguish it, we need to check the source mode and compare wit 000
000015BC                           602  * Only time where the source and dstiantion are in correct position
000015BC                           603  * This method is when both are data register
000015BC                           604  ***
000015BC                           605  ADD_AND_SUB_HELPER
000015BC  4EB9 000018F6            606      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
000015C2  4EB8 12D4                607      JSR         PRINT_NORMAL_SUFFIX
000015C6  4EB9 000019B2            608      JSR         PRINT_EMPTY_SPACE
000015CC  3638 0200                609      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
000015D0  4EB9 00001A22            610      JSR         CHECK_TYPE_DATA
000015D6  0C78 0000 0350           611      CMP         #0, SOURCE_MODE
000015DC  6600 002E                612      BNE         SUB_HELPER_FUNCTION                         * Utilize the not normal approach
000015E0  4EB9 000018FE            613      JSR         PRINT_DATA_MODE_SOURCE
000015E6  4EB9 00001952            614      JSR         PRINT_COMMA
000015EC  4EB9 000019B2            615      JSR         PRINT_EMPTY_SPACE
000015F2  4EB9 0000196A            616      JSR         PRINT_DATA_REGISTER
000015F8  31F8 0250 0550           617      MOVE.W      DESTINATION_VAR, THIRD_TEMP_VAR
000015FE  4EB8 12F6                618      JSR         PRINT_REGISTER_NUMBER
00001602  6100 FB88                619      BSR         USER_INPUT_ENTER
00001606  6000 FA36                620      BRA         PARSING_OP_CODE
0000160A  4E75                     621      RTS
0000160C                           622  
0000160C                           623  ***
0000160C                           624  * Helper for the helper method of ADD and SUB
0000160C                           625  * Used to handle cases with data register
0000160C                           626  * For whatever the data register is always the first 3 bit of the second nibble
0000160C                           627  * Even though it can either be in the source or destination when write it
0000160C                           628  * This method is when they are not both data register
0000160C                           629  ***
0000160C                           630  SUB_HELPER_FUNCTION
0000160C  3638 0200                631      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3                   * Need to swap places to print out
00001610  4EB9 00001A22            632      JSR         CHECK_TYPE_DATA
00001616  3638 0250                633      MOVE.W      DESTINATION_VAR,D3
0000161A  31F8 0400 0250           634      MOVE.W      SOURCE_VAR,DESTINATION_VAR
00001620  31C3 0400                635      MOVE.W      D3,SOURCE_VAR
00001624  3638 0300                636      MOVE.W      DESTINATION_MODE,D3
00001628  31F8 0350 0300           637      MOVE.W      SOURCE_MODE,DESTINATION_MODE
0000162E  31C3 0350                638      MOVE.W      D3,SOURCE_MODE
00001632  3638 0350                639      MOVE.W      SOURCE_MODE, D3
00001636  31F8 0400 0550           640      MOVE.W      SOURCE_VAR, THIRD_TEMP_VAR                  * Save the variable to print out from register
0000163C  E44B                     641      LSR         #2,D3
0000163E  B67C 0000                642      CMP         #0,D3                                       * Check direction to know which order we should be printing
00001642  6700 0024                643      BEQ         SUB_HELPER_REGISTER_TO_MEM
00001646  4EB9 00001D40            644      JSR         REGISTER_MODE_000                           * Need to find a way to switch the places
0000164C  4EB9 00001952            645      JSR         PRINT_COMMA
00001652  4EB9 000019B2            646      JSR         PRINT_EMPTY_SPACE
00001658  4EB9 00001918            647      JSR         PRINT_DATA_MODE_DESTINATION
0000165E  6100 FB2C                648      BSR         USER_INPUT_ENTER
00001662  6000 F9DA                649      BRA         PARSING_OP_CODE
00001666  4E75                     650      RTS
00001668                           651  
00001668                           652  ***
00001668                           653  * Helper method to help with printing from register to memory
00001668                           654  ***
00001668                           655  SUB_HELPER_REGISTER_TO_MEM
00001668  31F8 0250 0550           656      MOVE.W      DESTINATION_VAR, THIRD_TEMP_VAR
0000166E  4EB9 00001918            657      JSR         PRINT_DATA_MODE_DESTINATION
00001674  4EB9 00001952            658      JSR         PRINT_COMMA
0000167A  4EB9 000019B2            659      JSR         PRINT_EMPTY_SPACE
00001680  31F8 0400 0550           660      MOVE.W      SOURCE_VAR, THIRD_TEMP_VAR
00001686  4EB9 00001D40            661      JSR         REGISTER_MODE_000
0000168C  6100 FAFE                662      BSR         USER_INPUT_ENTER
00001690  6000 F9AC                663      BRA         PARSING_OP_CODE
00001694  4E75                     664      RTS
00001696                           665  
00001696                           666  ***
00001696                           667  * Print out the BRA instruction
00001696                           668  * Current limitation: Only can print out branch to a word address (4bytes).No support for 8 bytes
00001696                           669  ***
00001696                           670  PRINT_OUT_BRA
00001696  43F9 0000225C            671      LEA         BRA_VALUE,A1
0000169C  4EB9 000018F6            672      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
000016A2  4EB9 000019B2            673      JSR         PRINT_EMPTY_SPACE
000016A8  4EB9 000019A6            674      JSR         PRINT_HEX_SYMBOL
000016AE  380A                     675      MOVE.W      A2,D4                                       * Save the current address we are at
000016B0  4EB9 000019EA            676      JSR         GET_NEXT_FOUR_NIBBLE                        * Get the displacement we are suppose to branch to
000016B6  D843                     677      ADD         D3,D4                                       * Current address + displacement => address we are suppose to jump to
000016B8  31C4 0200                678      MOVE.W      D4, TEMP_CURRENT_4_NIBBLES                  * Prepare the address to print out in hex
000016BC  4EB8 1128                679      JSR         CONVERT_HEX_TO_ASCII
000016C0  6100 FACA                680      BSR         USER_INPUT_ENTER
000016C4  6000 F978                681      BRA         PARSING_OP_CODE
000016C8                           682  
000016C8                           683  ***
000016C8                           684  * Print out the BSR instruction
000016C8                           685  * limitation: Same like BRA
000016C8                           686  ***
000016C8                           687  PRINT_OUT_BSR
000016C8  43F9 00002262            688      LEA         BSR_VALUE,A1
000016CE  4EB9 000018F6            689      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
000016D4  4EB9 000019B2            690      JSR         PRINT_EMPTY_SPACE
000016DA  4EB9 000019A6            691      JSR         PRINT_HEX_SYMBOL
000016E0  380A                     692      MOVE.W      A2,D4
000016E2  4EB9 000019EA            693      JSR         GET_NEXT_FOUR_NIBBLE
000016E8  D843                     694      ADD         D3,D4
000016EA  31C4 0200                695      MOVE.W      D4,TEMP_CURRENT_4_NIBBLES
000016EE  4EB8 1128                696      JSR         CONVERT_HEX_TO_ASCII
000016F2  6100 FA98                697      BSR         USER_INPUT_ENTER
000016F6  6000 F946                698      BRA         PARSING_OP_CODE
000016FA                           699  
000016FA                           700  ***
000016FA                           701  * Print out the appropriate Bcc instruction using a jump table
000016FA                           702  ***
000016FA                           703  PRINT_OUT_Bcc
000016FA  43F9 0000233E            704      LEA         B,A1
00001700  4EB9 000018F6            705      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001706  4DF9 00002006            706      LEA         CONDITION_JUMP_TABLE,A6                     * Load the jump table to know which condition code to print
0000170C  3638 0200                707      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001710  4EB9 000019D0            708      JSR         GET_THE_SECOND_NIBBLE
00001716  C6FC 0006                709      MULU        #6,D3
0000171A  4EB6 3000                710      JSR         0(A6,D3)                                    * Now print out the suffix of B
0000171E  4EB9 000019B2            711      JSR         PRINT_EMPTY_SPACE
00001724  4EB9 000019A6            712      JSR         PRINT_HEX_SYMBOL
0000172A  380A                     713      MOVE.W      A2,D4                                       * Print out the address
0000172C  4EB9 000019EA            714      JSR         GET_NEXT_FOUR_NIBBLE
00001732  D843                     715      ADD         D3,D4
00001734  31C4 0200                716      MOVE.W      D4,TEMP_CURRENT_4_NIBBLES
00001738  4EB8 1128                717      JSR         CONVERT_HEX_TO_ASCII
0000173C  6100 FA4E                718      BSR         USER_INPUT_ENTER
00001740  6000 F8FC                719      BRA         PARSING_OP_CODE
00001744                           720  
00001744                           721  ***
00001744                           722  * Logical Shift instruction with single operand memory <ea>
00001744                           723  ***
00001744                           724  PRINT_OUT_LOGICAL_SHIFT_MEM
00001744  43F9 0000228A            725      LEA         LS_VALUE,A1
0000174A  4EB9 00001760            726      JSR         ASD_LSD_ROD_SHIFT_HELPER
00001750  4E75                     727      RTS
00001752                           728  
00001752                           729  ***
00001752                           730  * Arithmeic shift instruction with single operand memory <ea>
00001752                           731  ***
00001752                           732  PRINT_OUT_ARITH_SHIFT_MEM
00001752  43F9 00002286            733      LEA         AS_VALUE,A1
00001758  4EB9 00001760            734      JSR         ASD_LSD_ROD_SHIFT_HELPER
0000175E  4E75                     735      RTS
00001760                           736  
00001760                           737  ***
00001760                           738  * Helper method for ASd, LSd, ROd
00001760                           739  ***
00001760                           740  ASD_LSD_ROD_SHIFT_HELPER
00001760  4EB9 000018F6            741      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001766  4DF9 000020D6            742      LEA         RIGHT_OR_LEFT_JUMP_TABLE,A6                 * Print the direction, left or right
0000176C  3638 0200                743      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001770  4EB9 00001A22            744      JSR         CHECK_TYPE_DATA
00001776  4EB9 000019D0            745      JSR         GET_THE_SECOND_NIBBLE
0000177C  E14B                     746      LSL         #8,D3
0000177E  EF4B                     747      LSL         #7,D3
00001780  EE4B                     748      LSR         #7,D3
00001782  E04B                     749      LSR         #8,D3
00001784  C6FC 0006                750      MULU        #6,D3
00001788  4EB6 3000                751      JSR         0(A6,D3)                                    * Print out left or right
0000178C  4EB9 00001FE0            752      JSR         PRINT_NORMAL_WORD_SUFFIX
00001792  31F8 0400 0550           753      MOVE.W      SOURCE_VAR, THIRD_TEMP_VAR                  * Save the register number in case for print OUT
00001798  4EB9 000018FE            754      JSR         PRINT_DATA_MODE_SOURCE
0000179E  6100 F9EC                755      BSR         USER_INPUT_ENTER
000017A2  6000 F89A                756      BRA         PARSING_OP_CODE
000017A6  4E75                     757      RTS
000017A8                           758  
000017A8                           759  ***
000017A8                           760  * Print out the ROd instruction with operand memory <ea>
000017A8                           761  ***
000017A8                           762  PRINT_OUT_ROTATE_MEM
000017A8  43F9 0000228E            763      LEA         RO_VALUE,A1
000017AE  4EB8 1760                764      JSR         ASD_LSD_ROD_SHIFT_HELPER
000017B2  4E75                     765      RTS
000017B4                           766  
000017B4                           767  ***
000017B4                           768  * print out the ASd and LSd with other cases
000017B4                           769  * ASL Dx, Dy for example
000017B4                           770  * ASL #<data>, Dy
000017B4                           771  ***
000017B4                           772  PRINT_OUT_ASD_OR_LSD                                * For other ASd and LSd, the first  bit of the last nibble can be used to differentiate them
000017B4  3638 0200                773      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
000017B8  4EB9 000019E0            774      JSR         GET_THE_FOURTH_NIBBLE
000017BE  E64B                     775      LSR         #3,D3
000017C0  B67C 0000                776      CMP         #0,D3
000017C4  6700 0008                777      BEQ         PRINT_OUT_ASD                       * First bit is 0 for ASD
000017C8  6000 0012                778      BRA         PRINT_OUT_LSD                       * 1 for LSD
000017CC  4E75                     779      RTS
000017CE                           780  
000017CE                           781  ***
000017CE                           782  * Print out the ASD instruction with other cases
000017CE                           783  * ASL Dx, Dy
000017CE                           784  * ASL #<data>, Dy
000017CE                           785  ***
000017CE                           786  PRINT_OUT_ASD
000017CE  43F9 00002286            787      LEA         AS_VALUE,A1
000017D4  4EB9 0000180C            788      JSR         ASD_LSD_ROD_HELPER_FUNCTION
000017DA  4E75                     789      RTS
000017DC                           790  
000017DC                           791  ***
000017DC                           792  * Print out the LSd instruction with other cases
000017DC                           793  * LSR Dx, Dy
000017DC                           794  * LSR #<data>, Dy
000017DC                           795  ***
000017DC                           796  PRINT_OUT_LSD
000017DC  43F9 0000228A            797      LEA         LS_VALUE,A1
000017E2  4EB9 0000180C            798      JSR         ASD_LSD_ROD_HELPER_FUNCTION
000017E8  4E75                     799      RTS
000017EA                           800  
000017EA                           801  ***
000017EA                           802  * Print out the ROd instruction with other cases
000017EA                           803  * ROL Dx, Dy
000017EA                           804  * ROL #<data>, Dy
000017EA                           805  ***
000017EA                           806  PRINT_OUT_ROD
000017EA  3638 0200                807      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
000017EE  4EB9 000019E0            808      JSR         GET_THE_FOURTH_NIBBLE
000017F4  E64B                     809      LSR         #3,D3
000017F6  B67C 0001                810      CMP         #1,D3
000017FA  6600 F998                811      BNE         INVALID                                     * ROD ibly accept 1 as the first bit in the fourth nibbles
000017FE  43F9 0000228E            812      LEA         RO_VALUE,A1
00001804  4EB9 0000180C            813      JSR         ASD_LSD_ROD_HELPER_FUNCTION
0000180A  4E75                     814      RTS
0000180C                           815  
0000180C                           816  ***
0000180C                           817  * ASd, LSd, ROd instruction with other cases with 2 operands source and destionation
0000180C                           818  ***
0000180C                           819  ASD_LSD_ROD_HELPER_FUNCTION   *
0000180C  4EB9 000018F6            820      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001812  4DF9 000020D6            821      LEA         RIGHT_OR_LEFT_JUMP_TABLE,A6                 * Print the direction, left or right
00001818  3638 0200                822      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
0000181C  4EB9 00001A22            823      JSR         CHECK_TYPE_DATA
00001822  4EB9 000019D0            824      JSR         GET_THE_SECOND_NIBBLE
00001828  E14B                     825      LSL         #8,D3
0000182A  EF4B                     826      LSL         #7,D3
0000182C  E04B                     827      LSR         #8,D3
0000182E  EE4B                     828      LSR         #7,D3
00001830  C6FC 0006                829      MULU        #6,D3
00001834  4EB6 3000                830      JSR         0(A6,D3)                                    * Print out left or right
00001838  3638 0200                831      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
0000183C  4EB8 12D4                832      JSR         PRINT_NORMAL_SUFFIX                         * Print out .B, .W or .L
00001840  3638 0200                833      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3                   * Now we need to determine if its is immediate or register rotation
00001844  4EB9 000019D8            834      JSR         GET_THE_THIRD_NIBBLE
0000184A  E14B                     835      LSL         #8,D3
0000184C  ED4B                     836      LSL         #6,D3
0000184E  E04B                     837      LSR         #8,D3
00001850  EE4B                     838      LSR         #7,D3                                       * Now the third bit will be at the last position
00001852  4DF9 000020FA            839      LEA         IMMEDIATE_OR_REGISTER_JUMP_TABLE,A6
00001858  C6FC 0006                840      MULU        #6,D3
0000185C  4EB6 3000                841      JSR         0(A6,D3)
00001860  4EB9 0000196A            842      JSR         PRINT_DATA_REGISTER
00001866  3638 0200                843      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
0000186A  4EB9 00001A22            844      JSR         CHECK_TYPE_DATA
00001870  31F8 0400 0550           845      MOVE.W      SOURCE_VAR,THIRD_TEMP_VAR                   * Save the register number to print out
00001876  4EB8 12F6                846      JSR         PRINT_REGISTER_NUMBER
0000187A  6100 F910                847      BSR         USER_INPUT_ENTER
0000187E  6000 F7BE                848      BRA         PARSING_OP_CODE
00001882  4E75                     849      RTS
00001884                           850  
00001884                           851  ***
00001884                           852  *  Decide whether to print move or move a based the 3 bit at the destination mode
00001884                           853  ***
00001884                           854  MOVE_OPCODE_HELPER
00001884  3638 0200                855      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001888  4EB9 00001A22            856      JSR         CHECK_TYPE_DATA
0000188E  0C78 0001 0300           857      CMP         #%001, DESTINATION_MODE
00001894  6700 0008                858      BEQ         PRINT_OUT_MOVEA
00001898  6000 0010                859      BRA         PRINT_OUT_MOVE
0000189C  4E75                     860      RTS
0000189E                           861  
0000189E                           862  ***
0000189E                           863  * Print out MOVEA
0000189E                           864  * UTilized a helper method
0000189E                           865  ***
0000189E                           866  PRINT_OUT_MOVEA
0000189E  43F9 000022A4            867      LEA         MOVEA_VALUE,A1
000018A4  4EB9 000018B6            868      JSR         MOVE_SECOND_OPCODE_HELPER
000018AA                           869  
000018AA                           870  ***
000018AA                           871  * Print out MOVE
000018AA                           872  * Utlized a helper method
000018AA                           873  ***
000018AA                           874  PRINT_OUT_MOVE
000018AA  43F9 000022AC            875      LEA         MOVE_VALUE,A1
000018B0  4EB9 000018B6            876      JSR         MOVE_SECOND_OPCODE_HELPER
000018B6                           877  
000018B6                           878  ***
000018B6                           879  * Helper method for MOVE and MOVEA
000018B6                           880  ***
000018B6                           881  MOVE_SECOND_OPCODE_HELPER
000018B6  4EB9 000018F6            882      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
000018BC  4DF9 00001F6A            883      LEA         MOVE_SIZE_PRINT_JUMP_TABLE,A6                   * Special size for move instruction
000018C2  3638 0200                884      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
000018C6  4EB9 000019CA            885      JSR         GET_THE_FIRST_NIBBLE
000018CC  C6FC 0006                886      MULU        #6,D3
000018D0  4EB6 3000                887      JSR         0(A6,D3)
000018D4  4EB9 000018FE            888      JSR         PRINT_DATA_MODE_SOURCE
000018DA  4EB9 00001952            889      JSR         PRINT_COMMA
000018E0  4EB9 000019B2            890      JSR         PRINT_EMPTY_SPACE
000018E6  4EB9 00001918            891      JSR         PRINT_DATA_MODE_DESTINATION
000018EC  6100 F89E                892      BSR         USER_INPUT_ENTER
000018F0  6000 F74C                893      BRA         PARSING_OP_CODE
000018F4  4E75                     894      RTS
000018F6                           895  
000018F6                           896  ***
000018F6                           897  * Print whatever is stored in A1
000018F6                           898  ***
000018F6                           899  PRINT_TO_SCREEN_ENTIRE_STRING
000018F6  103C 000E                900      MOVE.B      #14,D0
000018FA  4E4F                     901      TRAP        #15
000018FC  4E75                     902      RTS
000018FE                           903  
000018FE                           904  ***
000018FE                           905  * Print the data containeds at the last 6 bit of op code
000018FE                           906  * Destionation var - destionation mode- source mode - source var
000018FE                           907  ***
000018FE                           908  PRINT_DATA_MODE_SOURCE         * Depnding on the mode, will print out appropriate data mode: Dn,An,(An),...
000018FE  4DF9 00001D10            909      LEA         REGISTER_MODE_JUMP_TABLE,A6
00001904  31F8 0400 0550           910      MOVE.W      SOURCE_VAR, THIRD_TEMP_VAR
0000190A  3638 0350                911      MOVE        SOURCE_MODE,D3
0000190E  C6FC 0006                912      MULU        #6,D3
00001912  4EB6 3000                913      JSR         0(A6,D3)       * Let's see what mode is this source mode
00001916  4E75                     914      RTS
00001918                           915  ***
00001918                           916  * Print the data contains in the 12-7 bit of op code
00001918                           917  * Destionation var - destionation mode - source mode - source var
00001918                           918  ***
00001918                           919  PRINT_DATA_MODE_DESTINATION
00001918  4DF9 00001D10            920      LEA         REGISTER_MODE_JUMP_TABLE,A6
0000191E  31F8 0250 0550           921      MOVE.W      DESTINATION_VAR, THIRD_TEMP_VAR             * Determine the Xn to print
00001924  3638 0300                922      MOVE.W      DESTINATION_MODE,D3
00001928  C6FC 0006                923      MULU        #6,D3
0000192C  4EB6 3000                924      JSR         0(A6,D3)
00001930  4E75                     925      RTS
00001932                           926  
00001932                           927  ***
00001932                           928  * Print out the address in which we are executing the disassembli
00001932                           929  * Should print out 00XX YYYY as the address location
00001932                           930  ***
00001932                           931  PRINT_ADDRESS_LOCATION
00001932  2A0A                     932      MOVE.L      A2,D5 * Save the address we are at
00001934  E04D                     933      LSR         #8,D5                                       * Shift 4 bytes left most to print out
00001936  E04D                     934      LSR         #8,D5
00001938  31C5 0200                935      MOVE.W      D5,TEMP_CURRENT_4_NIBBLES                   * Get the entire long address
0000193C  4EB8 1128                936      JSR         CONVERT_HEX_TO_ASCII
00001940  3A0A                     937      MOVE.W      A2,D5
00001942  31C5 0200                938      MOVE.W      D5,TEMP_CURRENT_4_NIBBLES
00001946  4EB8 1128                939      JSR         CONVERT_HEX_TO_ASCII
0000194A  4EB9 000019B2            940      JSR         PRINT_EMPTY_SPACE
00001950  4E75                     941      RTS
00001952                           942  
00001952                           943  ***
00001952                           944  * Print ','
00001952                           945  ***
00001952                           946  PRINT_COMMA
00001952  43F9 000022F2            947      LEA         COMMA,A1
00001958  4EB8 18F6                948      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
0000195C  4E75                     949      RTS
0000195E                           950  
0000195E                           951  ***
0000195E                           952  * Print 'A'
0000195E                           953  ***
0000195E                           954  PRINT_ADDRESS_REGISTER
0000195E  43F9 000022EE            955      LEA         ADDRESS_REGISTER,A1
00001964  4EB8 18F6                956      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001968  4E75                     957      RTS
0000196A                           958  
0000196A                           959  ***
0000196A                           960  * Print 'D'
0000196A                           961  ***
0000196A                           962  PRINT_DATA_REGISTER
0000196A  43F9 000022EA            963      LEA         DATA_REGISTER,A1
00001970  4EB8 18F6                964      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001974  4E75                     965      RTS
00001976                           966  
00001976                           967  ***
00001976                           968  * Print '('
00001976                           969  ***
00001976                           970  PRINT_OPEN_BRACKET
00001976  43F9 000022DA            971      LEA         OPENING_BRACKET,A1
0000197C  4EB8 18F6                972      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001980  4E75                     973      RTS
00001982                           974  
00001982                           975  ***
00001982                           976  * Print ')'
00001982                           977  ***
00001982                           978  PRINT_CLOSE_BRACKET
00001982  43F9 000022DE            979      LEA         CLOSING_BRACKET,A1
00001988  4EB8 18F6                980      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
0000198C  4E75                     981      RTS
0000198E                           982  
0000198E                           983  ***
0000198E                           984  * Print '+'
0000198E                           985  ***
0000198E                           986  PRINT_PLUS_SIGN
0000198E  43F9 000022E2            987      LEA         PLUS_SIGN,A1
00001994  4EB8 18F6                988      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001998  4E75                     989      RTS
0000199A                           990  
0000199A                           991  ***
0000199A                           992  * Print '-'
0000199A                           993  ***
0000199A                           994  PRINT_MINUS_SIGN
0000199A  43F9 000022E6            995      LEA         MINUS_SIGN,A1
000019A0  4EB8 18F6                996      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
000019A4  4E75                     997      RTS
000019A6                           998  
000019A6                           999  ***
000019A6                          1000  * print '$'
000019A6                          1001  ***
000019A6                          1002  PRINT_HEX_SYMBOL
000019A6  43F9 000022FE           1003      LEA         HEX_SYMBOL,A1
000019AC  4EB8 18F6               1004      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
000019B0  4E75                    1005      RTS
000019B2                          1006  
000019B2                          1007  ***
000019B2                          1008  * Print ' '
000019B2                          1009  ***
000019B2                          1010  PRINT_EMPTY_SPACE
000019B2  43F9 000022F6           1011      LEA         SPACE,A1
000019B8  4EB8 18F6               1012      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
000019BC  4E75                    1013      RTS
000019BE                          1014  
000019BE                          1015  ***
000019BE                          1016  * Print '#'
000019BE                          1017  ***
000019BE                          1018  PRINT_IMMEDIATE_DATA_SYMBOL
000019BE  43F9 00002302           1019      LEA         IMMEDIATE_DATA_SYMBOL,A1
000019C4  4EB8 18F6               1020      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
000019C8  4E75                    1021      RTS
000019CA                          1022  
000019CA                          1023  *******************************************************************************
000019CA                          1024  ***************************************
000019CA                          1025  * Query data section
000019CA                          1026  * Contains utility methods
000019CA                          1027  ***************************************
000019CA                          1028  *******************************************************************************
000019CA                          1029  
000019CA                          1030  ***
000019CA                          1031  * Get the left most byte. Assuming that the full word data is already store in D3
000019CA                          1032  ***
000019CA                          1033  GET_THE_FIRST_NIBBLE
000019CA  E04B                    1034      LSR         #8,D3                               * Shift 2 bytes to the rights
000019CC  E84B                    1035      LSR         #4,D3                               * Shift 1 byte to the right. Now left most byte is now the right most byte
000019CE  4E75                    1036      RTS
000019D0                          1037  
000019D0                          1038  ***
000019D0                          1039  * Get the second nibble from the left
000019D0                          1040  ***
000019D0                          1041  GET_THE_SECOND_NIBBLE
000019D0  E94B                    1042      LSL         #4,D3                               * Shift the left most byte to go away
000019D2  E84B                    1043      LSR         #4,D3                               * Return the original place
000019D4  E04B                    1044      LSR         #8,D3                               * Push the 2 right most byte out of the way
000019D6  4E75                    1045      RTS
000019D8                          1046  
000019D8                          1047  ***
000019D8                          1048  * Get the third nibble from the left
000019D8                          1049  ***
000019D8                          1050  GET_THE_THIRD_NIBBLE
000019D8  E14B                    1051      LSL         #8,D3                               * Bye byte 2 left most nibble
000019DA  E04B                    1052      LSR         #8,D3                               * Get rid of the 3 bytes that are infront
000019DC  E84B                    1053      LSR         #4,D3                               * Shift back to original position
000019DE  4E75                    1054      RTS
000019E0                          1055  
000019E0                          1056  ***
000019E0                          1057  * Get the fourth nibble from the left
000019E0                          1058  ***
000019E0                          1059  GET_THE_FOURTH_NIBBLE
000019E0  E14B                    1060      LSL         #8,D3
000019E2  E94B                    1061      LSL         #4,D3
000019E4  E04B                    1062      LSR         #8,D3
000019E6  E84B                    1063      LSR         #4,D3
000019E8  4E75                    1064      RTS
000019EA                          1065  
000019EA                          1066  ***
000019EA                          1067  * Advance 2 bytes for Word ( 4 nibbles)
000019EA                          1068  ***
000019EA                          1069  GET_NEXT_FOUR_NIBBLE
000019EA  361A                    1070      MOVE.W      (A2)+,D3
000019EC  31C3 0200               1071      MOVE.W      D3, TEMP_CURRENT_4_NIBBLES          * Copy the value into temp variable
000019F0  B7CA                    1072      CMPA.L      A2,A3                               * Check the starting and ending address if we have surpass it
000019F2  6F00 0020               1073      BLE         FINISH_DISASSEMBLING
000019F6  4E75                    1074      RTS
000019F8                          1075  
000019F8                          1076  ***
000019F8                          1077  * Advance 1 byte for word (2 nibbles)
000019F8                          1078  ***
000019F8                          1079  GET_NEXT_TWO_NIBBLE
000019F8  161A                    1080      MOVE.B      (A2)+,D3                            * Get the next byte ( 2 nibbles)
000019FA  11C3 0750               1081      MOVE.B      D3, TEMP_CURRENT_2_NIBBLES
000019FE  4E75                    1082      RTS
00001A00                          1083  
00001A00                          1084  ***
00001A00                          1085  * Get the normal size in the opcode, usually the first 2 bit of the third nibble
00001A00                          1086  ***
00001A00                          1087  GET_NORMAL_SIZE
00001A00  4EB9 00001A22           1088      JSR         CHECK_TYPE_DATA
00001A06  3638 0300               1089      MOVE.W      DESTINATION_MODE,D3
00001A0A  E14B                    1090      LSL         #8,D3
00001A0C  ED4B                    1091      LSL         #6,D3
00001A0E  E04B                    1092      LSR         #8,D3
00001A10  EC4B                    1093      LSR         #6,D3
00001A12  4E75                    1094      RTS
00001A14                          1095  
00001A14                          1096  ***
00001A14                          1097  * Display prompt saying that it has finished disassembling
00001A14                          1098  ***
00001A14                          1099  FINISH_DISASSEMBLING
00001A14  43F9 000021C6           1100      LEA         FINISH,A1
00001A1A  4EB8 18F6               1101      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001A1E  FFFF FFFF               1102      SIMHALT
00001A22                          1103  
00001A22                          1104  *******************************************************************************
00001A22                          1105  * logical reasoning section (determine what kind of opcode to print, what type of data to print)
00001A22                          1106  *******************************************************************************
00001A22                          1107  
00001A22                          1108  
00001A22                          1109  ***
00001A22                          1110  * getting the appropriate source and destination register  and mode
00001A22                          1111  * Destionation var - destionation mode - source mode - soruce var
00001A22                          1112  ***
00001A22                          1113  CHECK_TYPE_DATA
00001A22  3638 0200               1114      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001A26  E94B                    1115      LSL         #4,D3                               * Get rid of left most byte
00001A28  E84B                    1116      LSR         #4,D3                               * Now focus on the following format      destination mode mode source. Start with destination first
00001A2A  E04B                    1117      LSR         #8,D3                               * Now the D3 has the destination
00001A2C  E24B                    1118      LSR         #1,D3
00001A2E  31C3 0250               1119      MOVE.W      D3,DESTINATION_VAR
00001A32  3638 0200               1120      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3           * Now go with the destination mode
00001A36  EF4B                    1121      LSL         #7,D3
00001A38  EE4B                    1122      LSR         #7,D3
00001A3A  EC4B                    1123      LSR         #6,D3
00001A3C  31C3 0300               1124      MOVE.W      D3,DESTINATION_MODE
00001A40  3638 0200               1125      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3           * Now extract the source mode
00001A44  E14B                    1126      LSL         #8,D3
00001A46  E54B                    1127      LSL         #2,D3
00001A48  E04B                    1128      LSR         #8,D3
00001A4A  E44B                    1129      LSR         #2,D3
00001A4C  E64B                    1130      LSR         #3,D3
00001A4E  31C3 0350               1131      MOVE.W      D3,SOURCE_MODE                      * Now extract the source
00001A52  3638 0200               1132      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001A56  E14B                    1133      LSL         #8,D3
00001A58  EB4B                    1134      LSL         #5,D3
00001A5A  E04B                    1135      LSR         #8,D3
00001A5C  EA4B                    1136      LSR         #5,D3
00001A5E  31C3 0400               1137      MOVE.W      D3,SOURCE_VAR
00001A62  3638 0200               1138      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001A66  4E75                    1139      RTS
00001A68                          1140  
00001A68                          1141  ***
00001A68                          1142  * Reasoning section for NOP, JSR, RTS
00001A68                          1143  ***
00001A68                          1144  FIRST_NIBBLE_4_SECOND_NIBBLE_E
00001A68  3638 0200               1145      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001A6C  E14B                    1146      LSL         #8,D3                               * Shift to the left to dissappear 2 left most byte
00001A6E  E04B                    1147      LSR         #8,D3                               * Shift to the right to gain back original position. Only now the 2 left most byte are gone
00001A70  B63C 0071               1148      CMP.B       #$71,D3                             * NOP is 4E71
00001A74  6700 F786               1149      BEQ         PRINT_OUT_NOP
00001A78  B63C 0075               1150      CMP.B       #$75,D3                             *RTS is 4E75
00001A7C  6700 F792               1151      BEQ         PRINT_OUT_RTS
00001A80  3638 0200               1152      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001A84  4EB8 1A22               1153      JSR         CHECK_TYPE_DATA                     *  Get the destination mode and desitnation register. Could be JSR
00001A88  3638 0200               1154      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001A8C  4EB8 19D8               1155      JSR         GET_THE_THIRD_NIBBLE                * For Jsr  the 2 bit of the 3rd nibble is 10
00001A90  E44B                    1156      LSR         #2, D3
00001A92  B67C 0002               1157      CMP         #%10, D3
00001A96  6700 F7A4               1158      BEQ         PRINT_OUT_JSR                       * Print out the command JSR and the data
00001A9A  6000 F6F8               1159      BRA         INVALID
00001A9E  4E75                    1160      RTS
00001AA0                          1161  
00001AA0                          1162  ********************************************************************************
00001AA0                          1163  * Specific branching of the jump table is stored here
00001AA0                          1164  *******************************************************************************
00001AA0                          1165  FIRST_NIBBLE_JUMP_TABLE                  * Based on the first byte of the op code then jump on what is possible
00001AA0  4EF9 00001B00           1166      JMP         FIRST_NIBBLE_IS_0               * ORI, CMPI. BCLR
00001AA6  4EF9 00001B16           1167      JMP         FIRST_NIBBLE_IS_1               * MOVE.B, MOVEA.B
00001AAC  4EF9 00001B1E           1168      JMP         FIRST_NIBBLE_IS_2               * MOVEA.L, MOVE.L
00001AB2  4EF9 00001B26           1169      JMP         FIRST_NIBBLE_IS_3               * MOVE.W    MOVEA.W
00001AB8  4EF9 00001B2E           1170      JMP         FIRST_NIBBLE_IS_4               * NOP, LEA, NEG, JSR, RTS
00001ABE  4EF9 00001B5E           1171      JMP         FIRST_NIBBLE_IS_5               * SUBQ
00001AC4  4EF9 00001B94           1172      JMP         FIRST_NIBBLE_IS_6               * BCS, BGE, BLT, BVC, BRA
00001ACA  4EF9 00001BB6           1173      JMP         FIRST_NIBBLE_IS_7               * NOT SUPPORTED
00001AD0  4EF9 00001BD6           1174      JMP         FIRST_NIBBLE_IS_8               * DIVS, OR
00001AD6  4EF9 00001BFC           1175      JMP         FIRST_NIBBLE_IS_9               * SUB
00001ADC  4EF9 00001C18           1176      JMP         FIRST_NIBBLE_IS_A               * NOT SUPPORTED
00001AE2  4EF9 00001C20           1177      JMP         FIRST_NIBBLE_IS_B               * EOR, CMP
00001AE8  4EF9 00001C54           1178      JMP         FIRST_NIBBLE_IS_C               * MULS
00001AEE  4EF9 00001C8A           1179      JMP         FIRST_NIBBLE_IS_D               * ADD, ADDA
00001AF4  4EF9 00001CA8           1180      JMP         FIRST_NIBBLE_IS_E               * LSR, LSL, ASR, ASL, ROL, ROR
00001AFA  4EF9 00001CDE           1181      JMP         FIRST_NIBBLE_IS_F               * NOT SUPPORTED
00001B00                          1182  
00001B00                          1183  FIRST_NIBBLE_IS_0
00001B00  3638 0200               1184      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001B04  4EB8 19D0               1185      JSR         GET_THE_SECOND_NIBBLE
00001B08  B67C 000C               1186      CMP         #$C, D3
00001B0C  6700 F758               1187      BEQ         PRINT_OUT_CMPI
00001B10  6000 F682               1188      BRA         INVALID
00001B14  4E75                    1189      RTS
00001B16                          1190  
00001B16                          1191  
00001B16                          1192  FIRST_NIBBLE_IS_1 *MOVE.B, MOVEA.B * Can only be MOVE for these nibble because of the size of MOVE
00001B16  4EB8 1884               1193      JSR         MOVE_OPCODE_HELPER
00001B1A  FFFF FFFF               1194      SIMHALT
00001B1E                          1195  
00001B1E                          1196  FIRST_NIBBLE_IS_2 *MOVE.L, MOVEA.L
00001B1E  4EB8 1884               1197      JSR         MOVE_OPCODE_HELPER
00001B22  FFFF FFFF               1198      SIMHALT
00001B26                          1199  
00001B26                          1200  FIRST_NIBBLE_IS_3 * MOVE.W, MOVEA.W
00001B26  4EB8 1884               1201      JSR         MOVE_OPCODE_HELPER
00001B2A  FFFF FFFF               1202      SIMHALT
00001B2E                          1203  
00001B2E                          1204  FIRST_NIBBLE_IS_4                                       * Possible for NOP,LEA,RTS,JSR,NEG. Now will check the second byte
00001B2E  3638 0200               1205      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3               * Get the original op code back
00001B32  4EB8 19D0               1206      JSR         GET_THE_SECOND_NIBBLE
00001B36  B63C 000E               1207      CMP.B       #$E,D3
00001B3A  6700 FF2C               1208      BEQ         FIRST_NIBBLE_4_SECOND_NIBBLE_E          * NOP,RTS,JSR
00001B3E  B63C 0004               1209      CMP.B       #4,D3                                   *If the second nibble is 4, then it must be neg
00001B42  6700 F67E               1210      BEQ         PRINT_OUT_NEG
00001B46  3638 0200               1211      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001B4A  4EB8 1A22               1212      JSR         CHECK_TYPE_DATA
00001B4E  0C78 0007 0300          1213      CMP         #%111,DESTINATION_MODE
00001B54  6700 F7BA               1214      BEQ         PRINT_OUT_LEA                           * Only LEA have the 3 bits of destination is 111
00001B58  6000 F63A               1215      BRA         INVALID
00001B5C  4E75                    1216      RTS
00001B5E                          1217  
00001B5E                          1218  FIRST_NIBBLE_IS_5                                       * This is SUBQ and ADDQ
00001B5E  3638 0200               1219      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001B62  4EB8 1A22               1220      JSR         CHECK_TYPE_DATA
00001B66  4EB8 1A00               1221      JSR         GET_NORMAL_SIZE                         * SUBQ and ADDQ only accpet normal size. Meaning no 11
00001B6A  B67C 0003               1222      CMP         #%11,D3
00001B6E  6700 F624               1223      BEQ         INVALID
00001B72  3638 0200               1224      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001B76  4EB8 19D0               1225      JSR         GET_THE_SECOND_NIBBLE
00001B7A  E14B                    1226      LSL         #8,D3                                   * Get rid of the first 2 byets
00001B7C  EF4B                    1227      LSL         #7,D3                                   * Shift back to original position
00001B7E  E04B                    1228      LSR         #8,D3
00001B80  EE4B                    1229      LSR         #7,D3
00001B82  B67C 0000               1230      CMP         #0,D3                                   * SUBQ have 1 as the last bit in the second nibble
00001B86  6700 F7D0               1231      BEQ         PRINT_OUT_ADDQ                          * ADDQ has 0 as the last bit in the second nibble
00001B8A  6000 F7D6               1232      BRA         PRINT_OUT_SUBQ
00001B8E  4E75                    1233      RTS
00001B90  FFFF FFFF               1234      SIMHALT
00001B94                          1235  
00001B94                          1236  FIRST_NIBBLE_IS_6                                       * Bcc and BRA , BSR
00001B94  3638 0200               1237      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001B98  4EB8 19D0               1238      JSR         GET_THE_SECOND_NIBBLE
00001B9C  B67C 0000               1239      CMP         #%0000,D3                               * Only the condition code of BRA is 0000
00001BA0  6700 FAF4               1240      BEQ         PRINT_OUT_BRA
00001BA4  B67C 0001               1241      CMP         #%0001,D3
00001BA8  6700 FB1E               1242      BEQ         PRINT_OUT_BSR
00001BAC  6000 FB4C               1243      BRA         PRINT_OUT_Bcc
00001BB0  4E75                    1244      RTS
00001BB2  FFFF FFFF               1245      SIMHALT
00001BB6                          1246  
00001BB6                          1247  FIRST_NIBBLE_IS_7                                       * This is MOVEQ
00001BB6  3638 0200               1248      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001BBA  4EB8 19D0               1249      JSR         GET_THE_SECOND_NIBBLE
00001BBE  E14B                    1250      LSL         #8,D3
00001BC0  EF4B                    1251      LSL         #7,D3
00001BC2  E04B                    1252      LSR         #8,D3
00001BC4  EE4B                    1253      LSR         #7,D3
00001BC6  B67C 0000               1254      CMP         #0,D3
00001BCA  6700 F906               1255      BEQ         PRINT_OUT_MOVEQ
00001BCE  6000 F5C4               1256      BRA         INVALID
00001BD2  FFFF FFFF               1257      SIMHALT
00001BD6                          1258  
00001BD6                          1259  FIRST_NIBBLE_IS_8                                       * DIVS, Can't recognize SBCD
00001BD6  3638 0200               1260      MOVE.W      TEMP_CURRENT_4_NIBBLES, D3
00001BDA  4EB8 1A22               1261      JSR         CHECK_TYPE_DATA
00001BDE  0C78 0007 0300          1262      CMP         #%111, DESTINATION_MODE
00001BE4  6700 F7FC               1263      BEQ         PRINT_OUT_DIVS
00001BE8  0C78 0003 0300          1264      CMP         #%011, DESTINATION_MODE
00001BEE  6700 F5A4               1265      BEQ         INVALID                                 * This is DIVU
00001BF2  6000 F9AA               1266      BRA         PRINT_OUT_OR
00001BF6  4E75                    1267      RTS
00001BF8  FFFF FFFF               1268      SIMHALT
00001BFC                          1269  
00001BFC                          1270  FIRST_NIBBLE_IS_9                                       * SUB and SUBA           * No way of knowing SUX
00001BFC  3638 0200               1271      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001C00  4EB8 1A22               1272      JSR         CHECK_TYPE_DATA
00001C04  4EB8 1A00               1273      JSR         GET_NORMAL_SIZE
00001C08  B67C 0003               1274      CMP         #%11,D3
00001C0C  6700 F92C               1275      BEQ         PRINT_OUT_SUBA                          * SUB Does not accept the size of 11
00001C10  6000 F9A0               1276      BRA         PRINT_OUT_SUB
00001C14  FFFF FFFF               1277      SIMHALT
00001C18                          1278  
00001C18                          1279  FIRST_NIBBLE_IS_A                                       * There are not any opcode with 1010
00001C18  6000 F57A               1280      BRA         INVALID
00001C1C  FFFF FFFF               1281      SIMHALT
00001C20                          1282  
00001C20                          1283  FIRST_NIBBLE_IS_B                                       * CMP
00001C20  3638 0200               1284      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001C24  4EB8 1A22               1285      JSR         CHECK_TYPE_DATA
00001C28  4EB8 1A00               1286      JSR         GET_NORMAL_SIZE
00001C2C  B67C 0003               1287      CMP         #%11, D3
00001C30  6700 F562               1288      BEQ         INVALID                                 * CMP does not accept size 11
00001C34  3638 0200               1289      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001C38  4EB8 19D0               1290      JSR         GET_THE_SECOND_NIBBLE
00001C3C  E14B                    1291      LSL         #8,D3                                   * Get the last bit of the second nibble
00001C3E  EF4B                    1292      LSL         #7,D3
00001C40  EE4B                    1293      LSR         #7,D3
00001C42  E04B                    1294      LSR         #8,D3
00001C44  B67C 0000               1295      CMP         #0,D3                                   * CMP only accept 0 as the last bit in the second nibble
00001C48  6600 F54A               1296      BNE         INVALID
00001C4C  6000 F838               1297      BRA         PRINT_OUT_CMP
00001C50  FFFF FFFF               1298      SIMHALT
00001C54                          1299  
00001C54                          1300  FIRST_NIBBLE_IS_C                                       * MULS and MULU
00001C54  3638 0200               1301      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001C58  4EB8 1A22               1302      JSR         CHECK_TYPE_DATA
00001C5C  4EB8 1A00               1303      JSR         GET_NORMAL_SIZE
00001C60  B67C 0003               1304      CMP         #%11,D3
00001C64  6600 F52E               1305      BNE         INVALID                                 * MULS only accept 11 as the size
00001C68  3638 0200               1306      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001C6C  4EB8 19D0               1307      JSR         GET_THE_SECOND_NIBBLE
00001C70  E14B                    1308      LSL         #8,D3                                   * Get the last bit of the second
00001C72  EF4B                    1309      LSL         #7,D3
00001C74  EE4B                    1310      LSR         #7,D3
00001C76  E04B                    1311      LSR         #8,D3
00001C78  B67C 0001               1312      CMP         #1,D3                                   * If it is 1, then it is MULS. Otherwise MULU
00001C7C  6700 F7A8               1313      BEQ         PRINT_OUT_MULS
00001C80  6000 F7FC               1314      BRA         PRINT_OUT_MULU
00001C84  4E75                    1315      RTS
00001C86  FFFF FFFF               1316      SIMHALT
00001C8A                          1317  
00001C8A                          1318  FIRST_NIBBLE_IS_D *ADD, ADDA                            * Have no way of knowing ADDX
00001C8A  3638 0200               1319      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001C8E  4EB8 1A22               1320      JSR         CHECK_TYPE_DATA
00001C92  4EB8 1A00               1321      JSR         GET_NORMAL_SIZE
00001C96  B67C 0003               1322      CMP         #%11,D3
00001C9A  6700 F8A8               1323      BEQ         PRINT_OUT_ADDA
00001C9E  6000 F908               1324      BRA         PRINT_OUT_ADD
00001CA2  4E75                    1325      RTS
00001CA4  FFFF FFFF               1326      SIMHALT
00001CA8                          1327  
00001CA8                          1328  FIRST_NIBBLE_IS_E                                       * There are 2 types for every LSL,LSR,ASL,ASR,ROR,ROL. They can be seperated as LSd <ea> and other. They can be differentiate by the size 11
00001CA8  3638 0200               1329      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001CAC  4EB8 1A22               1330      JSR         CHECK_TYPE_DATA
00001CB0  4EB8 1A00               1331      JSR         GET_NORMAL_SIZE
00001CB4  B67C 0003               1332      CMP         #%11,D3
00001CB8  6700 002A               1333      BEQ         SPECIAL_SHIFT_INSTRUCTION               * Only the instructions with 11 in the size parts deal with <ea> (shift memory)
00001CBC  3638 0200               1334      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001CC0  4EB8 1A22               1335      JSR         CHECK_TYPE_DATA
00001CC4  4EB8 19D8               1336      JSR         GET_THE_THIRD_NIBBLE                    * For ASd and LSd, the lat bit is 0 of third nibble is 0
00001CC8  E14B                    1337      LSL         #8,D3                                   * Get the last bit of the second
00001CCA  EF4B                    1338      LSL         #7,D3
00001CCC  EE4B                    1339      LSR         #7,D3
00001CCE  E04B                    1340      LSR         #8,D3
00001CD0  B67C 0000               1341      CMP         #0,D3
00001CD4  6700 FADE               1342      BEQ         PRINT_OUT_ASD_OR_LSD
00001CD8  6000 FB10               1343      BRA         PRINT_OUT_ROD                           * Could also be ROXD. If it is then invalid
00001CDC  4E75                    1344      RTS
00001CDE                          1345  
00001CDE                          1346  
00001CDE                          1347  FIRST_NIBBLE_IS_F * UNSUPPORTED
00001CDE  4E75                    1348      RTS
00001CE0  FFFF FFFF               1349      SIMHALT
00001CE4                          1350  
00001CE4                          1351  SPECIAL_SHIFT_INSTRUCTION                               *Asd, LSd,ROd with <ea>. Shift instructions
00001CE4  3638 0200               1352      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00001CE8  4EB8 1A22               1353      JSR         CHECK_TYPE_DATA
00001CEC  4EB8 19D0               1354      JSR         GET_THE_SECOND_NIBBLE
00001CF0  E24B                    1355      LSR         #1, D3
00001CF2  B67C 0001               1356      CMP         #1,D3
00001CF6  6700 FA4C               1357      BEQ         PRINT_OUT_LOGICAL_SHIFT_MEM             * 001
00001CFA  B67C 0000               1358      CMP         #0,D3
00001CFE  6700 FA52               1359      BEQ         PRINT_OUT_ARITH_SHIFT_MEM               *000
00001D02  B67C 0003               1360      CMP         #%11,D3
00001D06  6700 FAA0               1361      BEQ         PRINT_OUT_ROTATE_MEM                    * 011
00001D0A  6000 F488               1362      BRA         INVALID                                 * Must be ROXd, UNSUPPORTED
00001D0E  4E75                    1363      RTS
00001D10                          1364  
00001D10                          1365  *******************************************************************************
00001D10                          1366  * Jump table section
00001D10                          1367  *******************************************************************************
00001D10                          1368  * Used to figure out what type of mode and address where used to print
00001D10                          1369  REGISTER_MODE_JUMP_TABLE
00001D10  4EF9 00001D40           1370      JMP         REGISTER_MODE_000                       * Data register mode Dn
00001D16  4EF9 00001D4A           1371      JMP         REGISTER_MODE_001                       * ADdress register mode   An
00001D1C  4EF9 00001D54           1372      JMP         REGISTER_MODE_010                       * Indirect address register mode (An)
00001D22  4EF9 00001D62           1373      JMP         REGISTER_MODE_011                       *  Address register with increment (An)+
00001D28  4EF9 00001D6C           1374      JMP         REGISTER_MODE_100                       * Address register with decrement -(An)
00001D2E  4EF9 00001D76           1375      JMP         REGISTER_MODE_101                       * Not supported
00001D34  4EF9 00001D7C           1376      JMP         REGISTER_MODE_110                       * Not supported
00001D3A  4EF9 00001D82           1377      JMP         REGISTER_MODE_111                       * This could be immediate, absolute short or absolute long
00001D40                          1378  
00001D40                          1379  REGISTER_MODE_000                                       * Print out data register Dn
00001D40  4EB8 196A               1380      JSR         PRINT_DATA_REGISTER
00001D44  4EB8 12F6               1381      JSR         PRINT_REGISTER_NUMBER
00001D48  4E75                    1382      RTS
00001D4A                          1383  
00001D4A                          1384  REGISTER_MODE_001           * An
00001D4A  4EB8 195E               1385      JSR         PRINT_ADDRESS_REGISTER
00001D4E  4EB8 12F6               1386      JSR         PRINT_REGISTER_NUMBER
00001D52  4E75                    1387      RTS
00001D54                          1388  
00001D54                          1389  REGISTER_MODE_010           * (An)
00001D54  4EB8 1976               1390      JSR         PRINT_OPEN_BRACKET
00001D58  4EB8 1D4A               1391      JSR         REGISTER_MODE_001
00001D5C  4EB8 1982               1392      JSR         PRINT_CLOSE_BRACKET
00001D60  4E75                    1393      RTS
00001D62                          1394  
00001D62                          1395  REGISTER_MODE_011           *(An)+
00001D62  4EB8 1D54               1396      JSR         REGISTER_MODE_010
00001D66  4EB8 198E               1397      JSR         PRINT_PLUS_SIGN
00001D6A  4E75                    1398      RTS
00001D6C                          1399  
00001D6C                          1400  REGISTER_MODE_100       * -(An)
00001D6C  4EB8 199A               1401      JSR         PRINT_MINUS_SIGN
00001D70  4EB8 1D54               1402      JSR         REGISTER_MODE_010
00001D74  4E75                    1403      RTS
00001D76                          1404  
00001D76                          1405  REGISTER_MODE_101                   * Not supported yet. Will deal later
00001D76  6000 F41C               1406      BRA         INVALID
00001D7A  4E75                    1407      RTS
00001D7C                          1408  
00001D7C                          1409  REGISTER_MODE_110                   * Not supported. Will deal later
00001D7C  6000 F416               1410      BRA         INVALID
00001D80  4E75                    1411      RTS
00001D82                          1412  
00001D82                          1413  REGISTER_MODE_111                               * Immediate data, absolute long or absolute short
00001D82  49F9 00001E06           1414      LEA         REGISTER_111_JUMP_TABLE,A4      * Print out the appropriate value
00001D88  3638 0550               1415      MOVE.W      THIRD_TEMP_VAR,D3
00001D8C  C6FC 0006               1416      MULU        #6,D3
00001D90  4EB4 3000               1417      JSR         0(A4,D3)
00001D94  49F9 00001DA8           1418      LEA         SHORT_OR_LONG_PRINT,A4          * Prepare the table to print out the data
00001D9A  3638 0550               1419      MOVE.W      THIRD_TEMP_VAR,D3
00001D9E  C6FC 0006               1420      MULU        #6,D3                           * Use THIRD_TEMP_VAR as a place holder for the data we want to print out for register mode 111.
00001DA2                          1421                                                  * In the code before this, we need to move the appropriate data into this address. Either the destination or the source
00001DA2  4EB4 3000               1422      JSR         0(A4,D3)                        * Print out the appropriate long or short value
00001DA6  4E75                    1423      RTS
00001DA8                          1424  
00001DA8                          1425  * Third table that deal with printing out short .W or .L value
00001DA8                          1426  SHORT_OR_LONG_PRINT                             * Will jump to this when the register mode is 111 and not immediate data
00001DA8  4EF9 00001DC6           1427      JMP         ABSOLUTE_SHORT                  * Xn index for this is 000
00001DAE  4EF9 00001DD4           1428      JMP         ABSOLUTE_LONG                   * Xn index for this is 001
00001DB4  4EF9 00001DE2           1429      JMP         COUNTER_DISPLACEMENT
00001DBA  4EF9 00001DEA           1430      JMP         COUNTER_INDEX
00001DC0  4EF9 00001DF2           1431      JMP         IMMEDIATE_DATA
00001DC6                          1432  
00001DC6                          1433  ABSOLUTE_SHORT                                  *We need to get the next 4 bytes as the address to print out
00001DC6  4EB8 19EA               1434      JSR         GET_NEXT_FOUR_NIBBLE            * Got next 4 nibbles to print out as address
00001DCA  4EB8 1128               1435      JSR         CONVERT_HEX_TO_ASCII
00001DCE  4E75                    1436      RTS
00001DD0  FFFF FFFF               1437      SIMHALT
00001DD4                          1438  
00001DD4                          1439  ABSOLUTE_LONG                                   * Print the next 8 bytes as the address
00001DD4  4EB8 1DC6               1440      JSR         ABSOLUTE_SHORT                  * PRinted 4 bytes
00001DD8  4EB8 1DC6               1441      JSR         ABSOLUTE_SHORT                  * Printed 4 more
00001DDC  4E75                    1442      RTS
00001DDE  FFFF FFFF               1443      SIMHALT
00001DE2                          1444  
00001DE2                          1445  COUNTER_DISPLACEMENT                            * Not SUPPORTED
00001DE2  6000 F3B0               1446      BRA         INVALID
00001DE6  FFFF FFFF               1447      SIMHALT
00001DEA                          1448  
00001DEA                          1449  COUNTER_INDEX                                   * Not SUPPORTED
00001DEA  6000 F3A8               1450      BRA         INVALID
00001DEE  FFFF FFFF               1451      SIMHALT
00001DF2                          1452  
00001DF2                          1453      * Immediate data is also like absolute short and long. Will take advantage of that
00001DF2                          1454  IMMEDIATE_DATA
00001DF2  4EB8 1A00               1455      JSR         GET_NORMAL_SIZE                 * Now the first 2 bit of third nibble is on the right most
00001DF6  E24B                    1456      LSR         #1, D3                          * Byte aand word are mapped to absolute short => 00 and 01 after shift will go to 00
00001DF8                          1457                                                  * If the size is long, the it will go to absolute long 10 => 01
00001DF8  49F8 1DA8               1458      LEA         SHORT_OR_LONG_PRINT,A4          * Prepare the table to print out the data
00001DFC  C6FC 0006               1459      MULU        #6,D3                           * Use THIRD_TEMP_VAR as a place holder for the data we want to print out for register mode 111.
00001E00                          1460                                                  * In the code before this, we need to move the appropriate data into this address. Either the destination or the source
00001E00                          1461  
00001E00  4EB4 3000               1462      JSR         0(A4,D3)                        * Print out the appropriate long or short value
00001E04  4E75                    1463      RTS
00001E06                          1464  
00001E06                          1465  REGISTER_111_JUMP_TABLE
00001E06  4EF9 00001E24           1466      JMP         PRINT_SHORT_SYMBOL
00001E0C  4EF9 00001E2A           1467      JMP         PRINT_LONG_SYMBOL
00001E12  4EF9 00001E30           1468      JMP         PLACE_HOLDER_3 * Won't be reached
00001E18  4EF9 00001E38           1469      JMP         PLACE_HOLDER_4
00001E1E  4EF9 00001E40           1470      JMP         PRINT_IMMEDIATE_DATA_AND_HEX
00001E24                          1471  
00001E24                          1472  PRINT_SHORT_SYMBOL
00001E24  4EB8 19A6               1473      JSR         PRINT_HEX_SYMBOL
00001E28  4E75                    1474      RTS
00001E2A                          1475  
00001E2A                          1476  PRINT_LONG_SYMBOL
00001E2A  4EB8 19A6               1477      JSR         PRINT_HEX_SYMBOL
00001E2E  4E75                    1478      RTS
00001E30                          1479  
00001E30                          1480  PLACE_HOLDER_3
00001E30  6000 F362               1481      BRA         INVALID
00001E34  FFFF FFFF               1482      SIMHALT
00001E38                          1483  
00001E38                          1484  PLACE_HOLDER_4
00001E38  6000 F35A               1485      BRA        INVALID
00001E3C  FFFF FFFF               1486      SIMHALT
00001E40                          1487  
00001E40                          1488  PRINT_IMMEDIATE_DATA_AND_HEX
00001E40  4EB8 19BE               1489      JSR         PRINT_IMMEDIATE_DATA_SYMBOL
00001E44  4EB8 19A6               1490      JSR         PRINT_HEX_SYMBOL
00001E48  4E75                    1491      RTS
00001E4A                          1492  
00001E4A                          1493  HEX_CHARACTER_JUMP_TABLE
00001E4A  4EF9 00001EAA           1494      JMP         PRINT_HEX_0
00001E50  4EF9 00001EB6           1495      JMP         PRINT_HEX_1
00001E56  4EF9 00001EC2           1496      JMP         PRINT_HEX_2
00001E5C  4EF9 00001ECE           1497      JMP         PRINT_HEX_3
00001E62  4EF9 00001EDA           1498      JMP         PRINT_HEX_4
00001E68  4EF9 00001EE6           1499      JMP         PRINT_HEX_5
00001E6E  4EF9 00001EF2           1500      JMP         PRINT_HEX_6
00001E74  4EF9 00001EFE           1501      JMP         PRINT_HEX_7
00001E7A  4EF9 00001F0A           1502      JMP         PRINT_HEX_8
00001E80  4EF9 00001F16           1503      JMP         PRINT_HEX_9
00001E86  4EF9 00001F22           1504      JMP         PRINT_HEX_A
00001E8C  4EF9 00001F2E           1505      JMP         PRINT_HEX_B
00001E92  4EF9 00001F3A           1506      JMP         PRINT_HEX_C
00001E98  4EF9 00001F46           1507      JMP         PRINT_HEX_D
00001E9E  4EF9 00001F52           1508      JMP         PRINT_HEX_E
00001EA4  4EF9 00001F5E           1509      JMP         PRINT_HEX_F
00001EAA                          1510  
00001EAA                          1511  PRINT_HEX_0
00001EAA  43F9 00002312           1512      LEA         ZERO,A1
00001EB0  4EB8 18F6               1513      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001EB4  4E75                    1514      RTS
00001EB6                          1515  
00001EB6                          1516  PRINT_HEX_1
00001EB6  43F9 00002316           1517      LEA         ONE,A1
00001EBC  4EB8 18F6               1518      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001EC0  4E75                    1519      RTS
00001EC2                          1520  
00001EC2                          1521  PRINT_HEX_2
00001EC2  43F9 0000231A           1522      LEA         TWO,A1
00001EC8  4EB8 18F6               1523      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001ECC  4E75                    1524      RTS
00001ECE                          1525  
00001ECE                          1526  PRINT_HEX_3
00001ECE  43F9 0000231E           1527      LEA         THREE,A1
00001ED4  4EB8 18F6               1528      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001ED8  4E75                    1529      RTS
00001EDA                          1530  
00001EDA                          1531  PRINT_HEX_4
00001EDA  43F9 00002322           1532      LEA         FOUR,A1
00001EE0  4EB8 18F6               1533      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001EE4  4E75                    1534      RTS
00001EE6                          1535  
00001EE6                          1536  PRINT_HEX_5
00001EE6  43F9 00002326           1537      LEA         FIVE,A1
00001EEC  4EB8 18F6               1538      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001EF0  4E75                    1539      RTS
00001EF2                          1540  
00001EF2                          1541  PRINT_HEX_6
00001EF2  43F9 0000232A           1542      LEA         SIX,A1
00001EF8  4EB8 18F6               1543      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001EFC  4E75                    1544      RTS
00001EFE                          1545  
00001EFE                          1546  PRINT_HEX_7
00001EFE  43F9 0000232E           1547      LEA         SEVEN,A1
00001F04  4EB8 18F6               1548      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001F08  4E75                    1549      RTS
00001F0A                          1550  
00001F0A                          1551  PRINT_HEX_8
00001F0A  43F9 00002332           1552      LEA         EIGHT,A1
00001F10  4EB8 18F6               1553      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001F14  4E75                    1554      RTS
00001F16                          1555  
00001F16                          1556  PRINT_HEX_9
00001F16  43F9 00002336           1557      LEA         NINE,A1
00001F1C  4EB8 18F6               1558      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001F20  4E75                    1559      RTS
00001F22                          1560  
00001F22                          1561  PRINT_HEX_A
00001F22  43F9 0000233A           1562      LEA         A,A1
00001F28  4EB8 18F6               1563      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001F2C  4E75                    1564      RTS
00001F2E                          1565  
00001F2E                          1566  PRINT_HEX_B
00001F2E  43F9 0000233E           1567      LEA         B,A1
00001F34  4EB8 18F6               1568      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001F38  4E75                    1569      RTS
00001F3A                          1570  
00001F3A                          1571  PRINT_HEX_C
00001F3A  43F9 00002342           1572      LEA         C,A1
00001F40  4EB8 18F6               1573      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001F44  4E75                    1574      RTS
00001F46                          1575  
00001F46                          1576  PRINT_HEX_D
00001F46  43F9 00002346           1577      LEA         D,A1
00001F4C  4EB8 18F6               1578      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001F50  4E75                    1579      RTS
00001F52                          1580  
00001F52                          1581  PRINT_HEX_E
00001F52  43F9 0000234A           1582      LEA         E,A1
00001F58  4EB8 18F6               1583      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001F5C  4E75                    1584      RTS
00001F5E                          1585  
00001F5E                          1586  PRINT_HEX_F
00001F5E  43F9 0000234E           1587      LEA         F,A1
00001F64  4EB8 18F6               1588      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001F68  4E75                    1589      RTS
00001F6A                          1590  
00001F6A                          1591  MOVE_SIZE_PRINT_JUMP_TABLE
00001F6A  4EF9 00001F82           1592      JMP         UNSUPPORTED_MOVE_SIZE
00001F70  4EF9 00001F88           1593      JMP         MOVE_BYTE_SUFFIX
00001F76  4EF9 00001F98           1594      JMP         MOVE_LONG_SUFFIX
00001F7C  4EF9 00001FA8           1595      JMP         MOVE_WORD_SUFFIX
00001F82                          1596  
00001F82                          1597  UNSUPPORTED_MOVE_SIZE
00001F82  6000 F210               1598      BRA         INVALID
00001F86  4E75                    1599      RTS
00001F88                          1600  
00001F88                          1601  MOVE_BYTE_SUFFIX
00001F88  43F9 00002306           1602      LEA         BYTE_SUFFIX,A1
00001F8E  4EB8 18F6               1603      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001F92  4EB8 19B2               1604      JSR         PRINT_EMPTY_SPACE
00001F96  4E75                    1605      RTS
00001F98                          1606  
00001F98                          1607  MOVE_LONG_SUFFIX
00001F98  43F9 0000230E           1608      LEA         LONG_SUFFIX,A1
00001F9E  4EB8 18F6               1609      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001FA2  4EB8 19B2               1610      JSR         PRINT_EMPTY_SPACE
00001FA6  4E75                    1611      RTS
00001FA8                          1612  
00001FA8                          1613  MOVE_WORD_SUFFIX
00001FA8  43F9 0000230A           1614      LEA         WORD_SUFFIX,A1
00001FAE  4EB8 18F6               1615      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001FB2  4EB8 19B2               1616      JSR         PRINT_EMPTY_SPACE
00001FB6  4E75                    1617      RTS
00001FB8                          1618  
00001FB8                          1619  
00001FB8                          1620  NORMAL_SIZE_PRINT_JUMP_TABLE
00001FB8  4EF9 00001FD0           1621      JMP         PRINT_NORMAL_BYTE_SUFFIX
00001FBE  4EF9 00001FE0           1622      JMP         PRINT_NORMAL_WORD_SUFFIX
00001FC4  4EF9 00001FF0           1623      JMP         PRINT_NORMAL_LONG_SUFFIX
00001FCA  4EF9 00002000           1624      JMP         UNSUPPORTED_NORMAL_SUFFIX         * Could be move
00001FD0                          1625  
00001FD0                          1626  PRINT_NORMAL_BYTE_SUFFIX
00001FD0  43F9 00002306           1627      LEA         BYTE_SUFFIX,A1
00001FD6  4EB8 18F6               1628      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001FDA  4EB8 19B2               1629      JSR         PRINT_EMPTY_SPACE
00001FDE  4E75                    1630      RTS
00001FE0                          1631  
00001FE0                          1632  PRINT_NORMAL_WORD_SUFFIX
00001FE0  43F9 0000230A           1633      LEA         WORD_SUFFIX,A1
00001FE6  4EB8 18F6               1634      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001FEA  4EB8 19B2               1635      JSR         PRINT_EMPTY_SPACE
00001FEE  4E75                    1636      RTS
00001FF0                          1637  
00001FF0                          1638  PRINT_NORMAL_LONG_SUFFIX
00001FF0  43F9 0000230E           1639      LEA         LONG_SUFFIX,A1
00001FF6  4EB8 18F6               1640      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00001FFA  4EB8 19B2               1641      JSR         PRINT_EMPTY_SPACE
00001FFE  4E75                    1642      RTS
00002000                          1643  
00002000                          1644  UNSUPPORTED_NORMAL_SUFFIX
00002000  6000 F192               1645      BRA         INVALID
00002004  4E75                    1646      RTS
00002006                          1647  
00002006                          1648  *This jump table depends on the condition of Bcc
00002006                          1649  CONDITION_JUMP_TABLE
00002006  4EF9 00002066           1650      JMP         CONDITION_TRUE
0000200C  4EF9 0000206A           1651      JMP         CONDITION_FALSE
00002012  4EF9 0000206E           1652      JMP         CONDITION_HIGHER
00002018  4EF9 00002072           1653      JMP         CONDITION_LOWER_OR_SAME
0000201E  4EF9 00002076           1654      JMP         CONDITION_CARRY_CLEAR
00002024  4EF9 0000207A           1655      JMP         CONDITION_CARRY_SET                * Supported
0000202A  4EF9 0000208A           1656      JMP         CONDITION_NOT_EQUAL
00002030  4EF9 0000208E           1657      JMP         CONDITION_EQUAL
00002036  4EF9 00002092           1658      JMP         CONDITION_OVERFLOW_CLEAR            * Supported
0000203C  4EF9 000020A2           1659      JMP         CONDITION_OVERFLOW_SET
00002042  4EF9 000020A6           1660      JMP         CONDITION_PLUS
00002048  4EF9 000020AA           1661      JMP         CONDITION_MINUS
0000204E  4EF9 000020AE           1662      JMP         CONDITION_GREATER_OR_EQUAL         * Supported
00002054  4EF9 000020BE           1663      JMP         CONDITION_LESS_THAN                * SUPPORTED
0000205A  4EF9 000020CE           1664      JMP         CONDITION_GREATER_THAN
00002060  4EF9 000020D2           1665      JMP         CONDITION_LESS_OR_EQUAL
00002066                          1666  
00002066                          1667  CONDITION_TRUE
00002066  6000 F12C               1668      BRA         INVALID
0000206A                          1669  
0000206A                          1670  CONDITION_FALSE
0000206A  6000 F128               1671      BRA         INVALID
0000206E                          1672  
0000206E                          1673  CONDITION_HIGHER
0000206E  6000 F124               1674      BRA         INVALID
00002072                          1675  
00002072                          1676  CONDITION_LOWER_OR_SAME
00002072  6000 F120               1677      BRA         INVALID
00002076                          1678  
00002076                          1679  CONDITION_CARRY_CLEAR
00002076  6000 F11C               1680      BRA         INVALID
0000207A                          1681  
0000207A                          1682  
0000207A                          1683  
0000207A                          1684  CONDITION_CARRY_SET
0000207A  43F9 000022CC           1685      LEA         CARRY_SET_VALUE,A1
00002080  4EB8 18F6               1686      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00002084  4EB8 19B2               1687      JSR         PRINT_EMPTY_SPACE
00002088  4E75                    1688      RTS
0000208A                          1689  
0000208A                          1690  CONDITION_NOT_EQUAL
0000208A  6000 F108               1691      BRA         INVALID
0000208E                          1692  CONDITION_EQUAL
0000208E  6000 F104               1693      BRA         INVALID
00002092                          1694  
00002092                          1695  CONDITION_OVERFLOW_CLEAR
00002092  43F9 000022C0           1696      LEA         OVERFLOW_CLEAR_VALUE,A1
00002098  4EB8 18F6               1697      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
0000209C  4EB8 19B2               1698      JSR         PRINT_EMPTY_SPACE
000020A0  4E75                    1699      RTS
000020A2                          1700  
000020A2                          1701  CONDITION_OVERFLOW_SET
000020A2  6000 F0F0               1702      BRA         INVALID
000020A6                          1703  
000020A6                          1704  CONDITION_PLUS
000020A6  6000 F0EC               1705      BRA         INVALID
000020AA                          1706  
000020AA                          1707  CONDITION_MINUS
000020AA  6000 F0E8               1708      BRA         INVALID
000020AE                          1709  
000020AE                          1710  CONDITION_GREATER_OR_EQUAL
000020AE  43F9 000022C4           1711      LEA         GREATER_OR_EQUAL_VALUE,A1
000020B4  4EB8 18F6               1712      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
000020B8  4EB8 19B2               1713      JSR         PRINT_EMPTY_SPACE
000020BC  4E75                    1714      RTS
000020BE                          1715  
000020BE                          1716  CONDITION_LESS_THAN
000020BE  43F9 000022C8           1717      LEA         LESS_THAN_VALUE,A1
000020C4  4EB8 18F6               1718      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
000020C8  4EB8 19B2               1719      JSR         PRINT_EMPTY_SPACE
000020CC  4E75                    1720      RTS
000020CE                          1721  
000020CE                          1722  CONDITION_GREATER_THAN
000020CE  6000 F0C4               1723      BRA         INVALID
000020D2                          1724  
000020D2                          1725  CONDITION_LESS_OR_EQUAL
000020D2  6000 F0C0               1726      BRA         INVALID
000020D6                          1727  
000020D6                          1728  RIGHT_OR_LEFT_JUMP_TABLE
000020D6  4EF9 000020E2           1729      JMP         RIGHT_DIRECTION_PRINT
000020DC  4EF9 000020EE           1730      JMP         LEFT_DIRECTION_PRINT
000020E2                          1731  
000020E2                          1732  RIGHT_DIRECTION_PRINT
000020E2  43F9 0000229C           1733      LEA         RIGHT_DIRECTION,A1
000020E8  4EB8 18F6               1734      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
000020EC  4E75                    1735      RTS
000020EE                          1736  
000020EE                          1737  LEFT_DIRECTION_PRINT
000020EE  43F9 00002298           1738      LEA         LEFT_DIRECTION,A1
000020F4  4EB8 18F6               1739      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
000020F8  4E75                    1740      RTS
000020FA                          1741  
000020FA                          1742  IMMEDIATE_OR_REGISTER_JUMP_TABLE                * Use for ASd, LSd, ROd operations
000020FA  4EF9 00002106           1743      JMP         IMMEDIATE_ROTATION
00002100  4EF9 00002134           1744      JMP         REGISTER_ROTATION
00002106                          1745  
00002106                          1746  IMMEDIATE_ROTATION
00002106  43F9 00002302           1747      LEA         IMMEDIATE_DATA_SYMBOL,A1
0000210C  4EB8 18F6               1748      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
00002110  3638 0200               1749      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00002114  4EB8 19D0               1750      JSR         GET_THE_SECOND_NIBBLE
00002118  E24B                    1751      LSR         #1,D3
0000211A  B67C 0000               1752      CMP         #0,D3
0000211E  6700 003A               1753      BEQ         IMMEDIATE_ROTATION_HELPER       * For cases where the immediate is 0, make it 8
00002122  31C3 0550               1754      MOVE.W      D3, THIRD_TEMP_VAR              * Save the immediate data 1-8 we want to print
00002126  4EB8 12F6               1755      JSR         PRINT_REGISTER_NUMBER
0000212A  4EB8 1952               1756      JSR         PRINT_COMMA
0000212E  4EB8 19B2               1757      JSR         PRINT_EMPTY_SPACE
00002132  4E75                    1758      RTS
00002134                          1759  
00002134                          1760  REGISTER_ROTATION
00002134  43F9 000022EA           1761      LEA         DATA_REGISTER,A1
0000213A  4EB8 18F6               1762      JSR         PRINT_TO_SCREEN_ENTIRE_STRING
0000213E  3638 0200               1763      MOVE.W      TEMP_CURRENT_4_NIBBLES,D3
00002142  4EB8 19D0               1764      JSR         GET_THE_SECOND_NIBBLE
00002146  E24B                    1765      LSR         #1,D3
00002148  31C3 0550               1766      MOVE.W      D3,THIRD_TEMP_VAR
0000214C  4EB8 12F6               1767      JSR         PRINT_REGISTER_NUMBER
00002150  4EB8 1952               1768      JSR         PRINT_COMMA
00002154  4EB8 19B2               1769      JSR         PRINT_EMPTY_SPACE
00002158  4E75                    1770      RTS
0000215A                          1771  
0000215A                          1772  IMMEDIATE_ROTATION_HELPER
0000215A  31FC 0008 0550          1773      MOVE.W      #8,THIRD_TEMP_VAR
00002160  4EB8 12F6               1774      JSR         PRINT_REGISTER_NUMBER
00002164  4EB8 1952               1775      JSR         PRINT_COMMA
00002168  4EB8 19B2               1776      JSR         PRINT_EMPTY_SPACE
0000216C  4E75                    1777      RTS
0000216E                          1778  
0000216E                          1779  
0000216E                          1780  
0000216E                          1781  ******************************************************************
0000216E                          1782  * Constant String that is used to print out the data is stored here
0000216E                          1783  ******************************************************************
0000216E= 506C 6561 7365 2...     1784  INTRO_STARTING          DC.W        'Please enter starting address',0
0000218E= 506C 6561 7365 2...     1785  INTRO_ENDING            DC.W        'Please enter ending address',0
000021AC= 494E 5641 4C49 4...     1786  INVALID_INPUT           DC.W        'INVALID ADDRESS ENTERED',0
000021C6= 4669 6E69 7368 2...     1787  FINISH                  DC.W        'Finish Dissassembling. Starting address has reached or passed ending address',0
00002214= 4E4F 5000 0000          1788  NOP_VALUE               DC.W        'NOP',0     * Requested
0000221A= 5254 5300 0000          1789  RTS_VALUE               DC.W        'RTS',0     * Requested
00002220= 4F52 4900 0000          1790  ORI_VALUE               DC.W        'ORI',0     * Unfinished
00002226= 4A53 5200 0000          1791  JSR_VALUE               DC.W        'JSR',0     * Requested
0000222C= 4C45 4100 0000          1792  LEA_VALUE               DC.W        'LEA',0     * Requested
00002232= 4E45 4700 0000          1793  NEG_VALUE               DC.W        'NEG',0     * Requested
00002238= 434D 5049 0000          1794  CMPI_VALUE              DC.W        'CMPI',0    * Requested
0000223E= 434D 5000 0000          1795  CMP_VALUE               DC.W        'CMP',0     * Requested
00002244= 5355 4200 0000          1796  SUB_VALUE               DC.W        'SUB',0     * Requested
0000224A= 5355 4241 0000          1797  SUBA_VALUE              DC.W        'SUBA',0    * Extra
00002250= 5355 4251 0000          1798  SUBQ_VALUE              DC.W        'SUBQ',0    * Requested
00002256= 4449 5653 0000          1799  DIVS_VALUE              DC.W        'DIVS',0    * Requested
0000225C= 4252 4100 0000          1800  BRA_VALUE               DC.W        'BRA',0     * Requested
00002262= 4253 5200 0000          1801  BSR_VALUE               DC.W        'BSR',0     * Extra
00002268= 4D55 4C53 0000          1802  MULS_VALUE              DC.W        'MULS',0    * Requested
0000226E= 4D55 4C55 0000          1803  MULU_VALUE              DC.W        'MULU',0    * Extra
00002274= 4144 4400 0000          1804  ADD_VALUE               DC.W        'ADD',0     * Requested
0000227A= 4144 4441 0000          1805  ADDA_VALUE              DC.W        'ADDA',0    * Requested
00002280= 4144 4451 0000          1806  ADDQ_VALUE              DC.W        'ADDQ',0    * Extra
00002286= 4153 0000               1807  AS_VALUE                DC.W        'AS',0      * Requested ASR, ASL
0000228A= 4C53 0000               1808  LS_VALUE                DC.W        'LS',0      * Requested LSR, LSL
0000228E= 524F 0000               1809  RO_VALUE                DC.W        'RO',0      * Requested ROR, ROL
00002292= 4243 4C52 0000          1810  BCLR_VALUE              DC.W        'BCLR',0    * Unfinished
00002298= 4C00 0000               1811  LEFT_DIRECTION          DC.W        'L',0
0000229C= 5200 0000               1812  RIGHT_DIRECTION         DC.W        'R',0
000022A0= 4F52 0000               1813  OR_VALUE                DC.W        'OR',0      * Extra
000022A4= 4D4F 5645 4100 0000     1814  MOVEA_VALUE             DC.W        'MOVEA',0   * Requested
000022AC= 4D4F 5645 0000          1815  MOVE_VALUE              DC.W        'MOVE',0    * Requested
000022B2= 4D4F 5645 5100 0000     1816  MOVEQ_VALUE             DC.W        'MOVEQ',0   * Extra
000022BA= 4441 5441 0000          1817  DATA_VALUE              DC.W        'DATA',0
000022C0= 5643 0000               1818  OVERFLOW_CLEAR_VALUE    DC.W        'VC',0
000022C4= 4745 0000               1819  GREATER_OR_EQUAL_VALUE  DC.W        'GE',0
000022C8= 4C54 0000               1820  LESS_THAN_VALUE         DC.W        'LT',0
000022CC= 4353 0000               1821  CARRY_SET_VALUE         DC.W        'CS',0
000022D0= 5352 0000               1822  SR_VALUE                DC.W        'SR',0
000022D4= 4343 5200 0000          1823  CCR_VALUE               DC.W        'CCR',0
000022DA= 2800 0000               1824  OPENING_BRACKET         DC.W        '(',0
000022DE= 2900 0000               1825  CLOSING_BRACKET         DC.W        ')',0
000022E2= 2B00 0000               1826  PLUS_SIGN               DC.W        '+',0
000022E6= 2D00 0000               1827  MINUS_SIGN              DC.W        '-',0
000022EA= 4400 0000               1828  DATA_REGISTER           DC.W        'D',0
000022EE= 4100 0000               1829  ADDRESS_REGISTER        DC.W        'A',0
000022F2= 2C00 0000               1830  COMMA                   DC.W        ',',0
000022F6= 2000 0000               1831  SPACE                   DC.W        ' ',0
000022FA= 2500 0000               1832  BINARY_SYMBOL           DC.W        '%',0
000022FE= 2400 0000               1833  HEX_SYMBOL              DC.W        '$',0
00002302= 2300 0000               1834  IMMEDIATE_DATA_SYMBOL   DC.W        '#',0
00002306= 2E42 0000               1835  BYTE_SUFFIX             DC.W        '.B',0
0000230A= 2E57 0000               1836  WORD_SUFFIX             DC.W        '.W',0
0000230E= 2E4C 0000               1837  LONG_SUFFIX             DC.W        '.L',0
00002312= 3000 0000               1838  ZERO                    DC.W        '0',0
00002316= 3100 0000               1839  ONE                     DC.W        '1',0
0000231A= 3200 0000               1840  TWO                     DC.W        '2',0
0000231E= 3300 0000               1841  THREE                   DC.W        '3',0
00002322= 3400 0000               1842  FOUR                    DC.W        '4',0
00002326= 3500 0000               1843  FIVE                    DC.W        '5',0
0000232A= 3600 0000               1844  SIX                     DC.W        '6',0
0000232E= 3700 0000               1845  SEVEN                   DC.W        '7',0
00002332= 3800 0000               1846  EIGHT                   DC.W        '8',0
00002336= 3900 0000               1847  NINE                    DC.W        '9',0
0000233A= 4100 0000               1848  A                       DC.W        'A',0
0000233E= 4200 0000               1849  B                       DC.W        'B',0
00002342= 4300 0000               1850  C                       DC.W        'C',0
00002346= 4400 0000               1851  D                       DC.W        'D',0
0000234A= 4500 0000               1852  E                       DC.W        'E',0
0000234E= 4600 0000               1853  F                       DC.W        'F',0
00002352                          1854  
00002352                          1855  
00002352                          1856      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
A                   233A
ABSOLUTE_LONG       1DD4
ABSOLUTE_SHORT      1DC6
ADDA_VALUE          227A
ADDQ_AND_SUBQ_HELPER  136C
ADDQ_VALUE          2280
ADDRESS_REGISTER    22EE
ADD_AND_SUB_HELPER  15BC
ADD_VALUE           2274
ASD_LSD_ROD_HELPER_FUNCTION  180C
ASD_LSD_ROD_SHIFT_HELPER  1760
AS_VALUE            2286
B                   233E
BCLR_VALUE          2292
BINARY_SYMBOL       22FA
BRA_VALUE           225C
BSR_VALUE           2262
BYTE_SUFFIX         2306
C                   2342
CARRY_SET_VALUE     22CC
CCR_VALUE           22D4
CHECK_TYPE_DATA     1A22
CLOSING_BRACKET     22DE
CMPI_VALUE          2238
CMP_VALUE           223E
COMMA               22F2
CONDITION_CARRY_CLEAR  2076
CONDITION_CARRY_SET  207A
CONDITION_EQUAL     208E
CONDITION_FALSE     206A
CONDITION_GREATER_OR_EQUAL  20AE
CONDITION_GREATER_THAN  20CE
CONDITION_HIGHER    206E
CONDITION_JUMP_TABLE  2006
CONDITION_LESS_OR_EQUAL  20D2
CONDITION_LESS_THAN  20BE
CONDITION_LOWER_OR_SAME  2072
CONDITION_MINUS     20AA
CONDITION_NOT_EQUAL  208A
CONDITION_OVERFLOW_CLEAR  2092
CONDITION_OVERFLOW_SET  20A2
CONDITION_PLUS      20A6
CONDITION_TRUE      2066
CONVERT_ASCII_TO_HEX  1060
CONVERT_CHARACTER_ASCII_TO_HEX  1086
CONVERT_HEX_TO_ASCII  1128
COUNTER_DISPLACEMENT  1DE2
COUNTER_INDEX       1DEA
D                   2346
DATA_REGISTER       22EA
DATA_VALUE          22BA
DESTINATION_MODE    300
DESTINATION_VAR     250
DIVS_VALUE          2256
E                   234A
EIGHT               2332
ENDING_ADDRESS      150
ERROR_INVALID_INPUT  1120
F                   234E
FIFTH_TEMP_VAR      650
FINISH              21C6
FINISH_CONVERT_ENDING_ADDRESS  10C4
FINISH_CONVERT_STARTING_ADDRESS  10AA
FINISH_DISASSEMBLING  1A14
FIRST_NIBBLE_4_SECOND_NIBBLE_E  1A68
FIRST_NIBBLE_IS_0   1B00
FIRST_NIBBLE_IS_1   1B16
FIRST_NIBBLE_IS_2   1B1E
FIRST_NIBBLE_IS_3   1B26
FIRST_NIBBLE_IS_4   1B2E
FIRST_NIBBLE_IS_5   1B5E
FIRST_NIBBLE_IS_6   1B94
FIRST_NIBBLE_IS_7   1BB6
FIRST_NIBBLE_IS_8   1BD6
FIRST_NIBBLE_IS_9   1BFC
FIRST_NIBBLE_IS_A   1C18
FIRST_NIBBLE_IS_B   1C20
FIRST_NIBBLE_IS_C   1C54
FIRST_NIBBLE_IS_D   1C8A
FIRST_NIBBLE_IS_E   1CA8
FIRST_NIBBLE_IS_F   1CDE
FIRST_NIBBLE_JUMP_TABLE  1AA0
FIVE                2326
FOUR                2322
FOURTH_TEMP_VAR     600
GET_END_ADDRESS     1024
GET_NEXT_FOUR_NIBBLE  19EA
GET_NEXT_TWO_NIBBLE  19F8
GET_NORMAL_SIZE     1A00
GET_START_ADDRESS   1000
GET_THE_FIRST_NIBBLE  19CA
GET_THE_FOURTH_NIBBLE  19E0
GET_THE_SECOND_NIBBLE  19D0
GET_THE_THIRD_NIBBLE  19D8
GREATER_OR_EQUAL_VALUE  22C4
HEX_CHARACTER_JUMP_TABLE  1E4A
HEX_SYMBOL          22FE
IMMEDIATE_DATA      1DF2
IMMEDIATE_DATA_SYMBOL  2302
IMMEDIATE_OR_REGISTER_JUMP_TABLE  20FA
IMMEDIATE_ROTATION  2106
IMMEDIATE_ROTATION_HELPER  215A
INTRO_ENDING        218E
INTRO_STARTING      216E
INVALID             1194
INVALID_ENDING_ADDRESS  1108
INVALID_INPUT       21AC
INVALID_STARTING_ADDRESS  10F0
JSR_VALUE           2226
LEA_VALUE           222C
LEFT_DIRECTION      2298
LEFT_DIRECTION_PRINT  20EE
LESS_THAN_VALUE     22C8
LONG_SUFFIX         230E
LS_VALUE            228A
MINUS_SIGN          22E6
MOVEA_VALUE         22A4
MOVEQ_VALUE         22B2
MOVE_BYTE_SUFFIX    1F88
MOVE_LONG_SUFFIX    1F98
MOVE_OPCODE_HELPER  1884
MOVE_SECOND_OPCODE_HELPER  18B6
MOVE_SIZE_PRINT_JUMP_TABLE  1F6A
MOVE_VALUE          22AC
MOVE_WORD_SUFFIX    1FA8
MULS_AND_MULU_HELPER  1430
MULS_VALUE          2268
MULU_VALUE          226E
NEG_VALUE           2232
NINE                2336
NOP_VALUE           2214
NORMAL_SIZE_PRINT_JUMP_TABLE  1FB8
ONE                 2316
OPENING_BRACKET     22DA
ORI_VALUE           2220
OR_VALUE            22A0
OVERFLOW_CLEAR_VALUE  22C0
PARSING_OP_CODE     103E
PLACE_HOLDER_3      1E30
PLACE_HOLDER_4      1E38
PLUS_SIGN           22E2
PREPARE_START_AND_END_ADDRESS  117A
PRINT_ADDRESS_LOCATION  1932
PRINT_ADDRESS_REGISTER  195E
PRINT_CLOSE_BRACKET  1982
PRINT_COMMA         1952
PRINT_DATA_MODE_DESTINATION  1918
PRINT_DATA_MODE_SOURCE  18FE
PRINT_DATA_REGISTER  196A
PRINT_EMPTY_SPACE   19B2
PRINT_HEX_0         1EAA
PRINT_HEX_1         1EB6
PRINT_HEX_2         1EC2
PRINT_HEX_3         1ECE
PRINT_HEX_4         1EDA
PRINT_HEX_5         1EE6
PRINT_HEX_6         1EF2
PRINT_HEX_7         1EFE
PRINT_HEX_8         1F0A
PRINT_HEX_9         1F16
PRINT_HEX_A         1F22
PRINT_HEX_B         1F2E
PRINT_HEX_C         1F3A
PRINT_HEX_D         1F46
PRINT_HEX_E         1F52
PRINT_HEX_F         1F5E
PRINT_HEX_SYMBOL    19A6
PRINT_IMMEDIATE_DATA_AND_HEX  1E40
PRINT_IMMEDIATE_DATA_SYMBOL  19BE
PRINT_LONG_SYMBOL   1E2A
PRINT_MINUS_SIGN    199A
PRINT_NORMAL_BYTE_SUFFIX  1FD0
PRINT_NORMAL_LONG_SUFFIX  1FF0
PRINT_NORMAL_SUFFIX  12D4
PRINT_NORMAL_WORD_SUFFIX  1FE0
PRINT_NOT_NORMAL_SUFFIX  12C2
PRINT_OPEN_BRACKET  1976
PRINT_OUT_ADD       15A8
PRINT_OUT_ADDA      1544
PRINT_OUT_ADDQ      1358
PRINT_OUT_ARITH_SHIFT_MEM  1752
PRINT_OUT_ASD       17CE
PRINT_OUT_ASD_OR_LSD  17B4
PRINT_OUT_BCC       16FA
PRINT_OUT_BRA       1696
PRINT_OUT_BSR       16C8
PRINT_OUT_CMP       1486
PRINT_OUT_CMPI      1266
PRINT_OUT_DIVS      13E2
PRINT_OUT_JSR       123C
PRINT_OUT_LEA       1310
PRINT_OUT_LOGICAL_SHIFT_MEM  1744
PRINT_OUT_LSD       17DC
PRINT_OUT_MOVE      18AA
PRINT_OUT_MOVEA     189E
PRINT_OUT_MOVEQ     14D2
PRINT_OUT_MULS      1426
PRINT_OUT_MULU      147E
PRINT_OUT_NEG       11C2
PRINT_OUT_NOP       11FC
PRINT_OUT_OR        159E
PRINT_OUT_ORI_TO_SR  1226
PRINT_OUT_ROD       17EA
PRINT_OUT_ROTATE_MEM  17A8
PRINT_OUT_RTS       1210
PRINT_OUT_SUB       15B2
PRINT_OUT_SUBA      153A
PRINT_OUT_SUBQ      1362
PRINT_PLUS_SIGN     198E
PRINT_REGISTER_NUMBER  12F6
PRINT_SHORT_SYMBOL  1E24
PRINT_TO_SCREEN_ENTIRE_STRING  18F6
REGISTER_111_JUMP_TABLE  1E06
REGISTER_MODE_000   1D40
REGISTER_MODE_001   1D4A
REGISTER_MODE_010   1D54
REGISTER_MODE_011   1D62
REGISTER_MODE_100   1D6C
REGISTER_MODE_101   1D76
REGISTER_MODE_110   1D7C
REGISTER_MODE_111   1D82
REGISTER_MODE_JUMP_TABLE  1D10
REGISTER_ROTATION   2134
RIGHT_DIRECTION     229C
RIGHT_DIRECTION_PRINT  20E2
RIGHT_OR_LEFT_JUMP_TABLE  20D6
RO_VALUE            228E
RTS_VALUE           221A
SEVEN               232E
SHORT_OR_LONG_PRINT  1DA8
SIX                 232A
SOURCE_MODE         350
SOURCE_VAR          400
SPACE               22F6
SPECIAL_SHIFT_INSTRUCTION  1CE4
SR_VALUE            22D0
START               1000
STARTING_ADDRESS    100
SUBA_AND_ADDA_HELPER  154E
SUBA_VALUE          224A
SUBQ_HELPER_FUNCTION  13BC
SUBQ_VALUE          2250
SUB_HELPER_FUNCTION  160C
SUB_HELPER_REGISTER_TO_MEM  1668
SUB_VALUE           2244
TEMP_CURRENT_2_NIBBLES  750
TEMP_CURRENT_4_NIBBLES  200
THIRD_TEMP_VAR      550
THREE               231E
TWO                 231A
UNSUPPORTED_MOVE_SIZE  1F82
UNSUPPORTED_NORMAL_SUFFIX  2000
USER_INPUT_ENTER    118C
WORD_SUFFIX         230A
ZERO                2312
